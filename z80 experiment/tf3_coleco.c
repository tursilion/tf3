/* 2023 by Tursilion
// This is the loader for TF3 Music player
// It sets up bitmap mode, displays the SEGA logo,
// and starts the program
*/

// we'll see how much we can fit in the fixed 16k
#include <vdp.h>
#include <kscan.h>
#include <sound.h>
#include <ColecoSNPlay.h>

unsigned char world, srow, scol, k;
const unsigned char *SongBank;

void START();

#define SWITCH_IN_BANK(nBank) (*(volatile unsigned char*)0)=(*(volatile unsigned char*)nBank); 

const unsigned char COL0[] = {	
/* 
// SEGA logo - 5 frames. 12x4, starting at row 1, not 0
// fifth frame is back at row 1, but column 12.
// ***************************************
// Colorset Definitions                  
// ***************************************
*/
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,    
0x47,0x47,0x47,0xF7,0x47,0xF7,0x47,0xF7,    
0x40,0x40,0x40,0x4F,0x40,0x40,0x40,0x40,    
0x74,0x74,0x74,0x7F,0x7F,0xF4,0xF4,0xF4,    
0xF4,0xF4,0xF4,0xF4,0xF4,0x74,0x47,0x47,    
0x14,0x40,0x40,0xF0,0x40,0x40,0x40,0x40,    
0x74,0x74,0xF4,0x7F,0xF4,0xF7,0xF4,0xF7,    
0xF4,0xF4,0xF4,0x4F,0xF4,0xF4,0xF4,0xF4,    
0x40,0x40,0x40,0xF0,0x40,0x40,0x40,0x40,    
0xF1,0xF1,0xE1,0xF1,0x71,0x15,0x71,0x15,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0x4F,0x4F,0xF4,0x1F,0x10,0xF1,0xF1,0xF1,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0x14,0x40,0x14,0x4F,0x14,0x40,0x14,0x40,    
0xF4,0xF4,0xF4,0x4F,0x4F,0xF4,0xF4,0xF4,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0x14,0x14,0x41,0xF0,0x14,0x14,0x14,0x40,    
0xF4,0xF4,0xF4,0x4F,0xF4,0xF4,0xF4,0xF4,    
0x14,0x40,0x41,0xF0,0x14,0x40,0x41,0x40,    
0xF1,0xF1,0xF1,0xF1,0xF1,0x15,0xF1,0x15,    
0xF4,0xF4,0xF4,0xF4,0xF1,0xF4,0xE4,0xF4,    
0x1F,0x4F,0xF1,0x1F,0x10,0xF1,0xF1,0xF1,    
0xF7,0xF7,0xF0,0xF7,0xF7,0xF7,0xF7,0xF0,    
0x74,0x47,0x4F,0x47,0x74,0x47,0x47,0xF0,    
0x47,0x74,0x74,0xF4,0xF4,0x17,0xF1,0xF1,    
0x47,0xF7,0xF7,0x70,0x47,0x70,0xF7,0x1F,    
0x74,0x74,0xF0,0x40,0x74,0x74,0x74,0xF0,    
0x47,0x47,0x7F,0x47,0x47,0x74,0xF4,0x1F,    
0x47,0xF7,0x7F,0x47,0x47,0x47,0x47,0xF0,    
0xF4,0xF4,0x4F,0x74,0x74,0x74,0x74,0xF0,    
0x47,0x47,0x47,0x47,0x47,0x47,0x47,0xF0,    
0x47,0x47,0x7F,0x47,0xF7,0xF7,0xF7,0xF0,    
0xF4,0xF4,0x4F,0x40,0x40,0x40,0x74,0xF0,    
0x41,0x14,0x14,0x14,0x14,0x14,0x14,0x1F,    
0x47,0x47,0xF0,0x47,0x47,0x47,0x47,0xF0,    
0x40,0xF4,0x4F,0x40,0x40,0x40,0x40,0xF0,    
0xF4,0x74,0x74,0xF4,0x74,0xF1,0xF1,0xF1,    
0xF4,0xF4,0xF4,0x74,0x74,0x74,0xF4,0x1F,    
0x14,0x40,0xF0,0x40,0x40,0x40,0x40,0xF0,    
0x74,0x74,0x7F,0xF4,0x47,0xF4,0xF1,0x1F,    
0xF4,0xF4,0x4F,0x40,0x74,0x74,0x74,0xF0,    
0xF4,0xF4,0x4F,0x14,0x14,0x40,0x40,0xF0,    
0x74,0x74,0x74,0x74,0x74,0x47,0x74,0xF0,    
0xF4,0xF4,0x4F,0xF4,0xF4,0xF4,0xF4,0xF0,    
0xE4,0xF4,0x4F,0x40,0x14,0x40,0x14,0xF0,    
0xF1,0x14,0x41,0x14,0x41,0x14,0x41,0x1F,    
0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,    
0x74,0x47,0x47,0x7F,0x47,0x70,0x47,0x70,    
0x74,0x74,0x74,0x7F,0x7F,0xF7,0xF4,0xF7,    
0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,    
0x74,0x74,0x74,0xF0,0x74,0x47,0x47,0x47,    
0x47,0x47,0x47,0x7F,0xF7,0xF7,0xF7,0xF7,    
0x47,0x47,0x47,0x7F,0xF7,0xF7,0xF7,0xF7,    
0x74,0x74,0x74,0xF0,0x74,0x74,0x74,0x74,    
0xF1,0xF1,0x17,0x1F,0xF1,0x17,0x17,0x17,    
0xF7,0xF7,0x47,0xF7,0xF7,0xF7,0xF7,0xF7,    
0xF4,0xF4,0xF4,0xF4,0xF4,0x47,0xF4,0x47,    
0x47,0x47,0xF0,0x47,0x47,0x47,0x47,0xF0,    
0x47,0xF7,0x7F,0x70,0x47,0x70,0x47,0xF0,    
0x47,0xF7,0x47,0x17,0x17,0x17,0xE1,0xF1,    
0x47,0xF7,0xF7,0x47,0x47,0x47,0xF7,0x1F,    
0x47,0x47,0xF0,0x70,0x70,0x70,0x70,0xF0,    
0x74,0x47,0x7F,0xF4,0xF7,0x47,0x17,0x1F,    
0xF7,0xF7,0x7F,0x70,0x47,0x70,0x47,0xF0,    
0x47,0x47,0x7F,0x47,0x47,0x47,0x70,0xF0,    
0x74,0xF7,0x74,0x74,0x74,0x74,0x74,0xF0,    
0xF7,0xF7,0x7F,0xF7,0xF7,0xF7,0xF7,0xF0,    
0x47,0xF7,0x7F,0x47,0x47,0x70,0x47,0xF0,    
0x15,0x15,0x17,0x15,0x15,0x17,0x17,0x1F,    
0x47,0xF4,0x47,0xF4,0xF4,0xF4,0xF4,0xF4,    
0x47,0x70,0x47,0x7F,0x47,0x70,0x47,0x47,    
0x47,0x47,0x47,0x4F,0x4F,0xF7,0xF4,0x47,    
0x74,0x47,0x74,0xF7,0x74,0x47,0x74,0x74,    
0x47,0x70,0x70,0xF0,0x47,0x70,0x47,0x70,    
0x47,0x47,0x47,0x4F,0xF4,0xF4,0xF4,0x4F,    
0xF7,0xF7,0x47,0x7F,0xF7,0x47,0x47,0x47,    
0x70,0x70,0x70,0xF0,0x47,0x70,0x70,0x70,    
0xF1,0xF1,0x17,0xF1,0x17,0x17,0x17,0x17,    
0xF7,0xF7,0x47,0xF7,0x47,0x47,0x47,0x47,    
0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,    
0x4F,0x7F,0x47,0x1F,0x10,0xF1,0xF1,0xF1,    
0xF4,0xF4,0xF0,0xF4,0xF4,0xF4,0xF4,0xF0,    
0x74,0xF4,0x7F,0x40,0x74,0x74,0x74,0xF0,    
0x47,0x47,0x74,0x17,0x74,0x17,0xF1,0xF1,    
0xF4,0xF4,0xF4,0x40,0x40,0x40,0xF4,0x1F,    
0x47,0x74,0xF0,0x74,0x74,0x74,0x74,0xF0,    
0x47,0x47,0x4F,0x47,0x74,0x47,0x17,0x1F,    
0x74,0xF4,0x4F,0x40,0x74,0x40,0x40,0xF0,    
0x47,0xF7,0x7F,0x47,0x47,0x74,0x74,0xF0,    
0xF4,0x74,0x74,0x74,0x74,0x74,0x74,0xF0,    
0x47,0xF4,0x4F,0xF4,0xF4,0xF4,0xF4,0xF0,    
0x47,0xF7,0x7F,0x47,0x47,0x47,0x47,0xF0,    
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x1F,    
0x74,0x40,0x74,0x4F,0x40,0x40,0x40,0x40,    
0x74,0x74,0x74,0x4F,0x4F,0xF4,0xF4,0xF4,    
0x74,0x74,0x74,0xF0,0x74,0x74,0x74,0x40,    
0x74,0x47,0x74,0x4F,0xF4,0xF4,0xF4,0xF4,    
0x74,0xF4,0xF4,0x4F,0xF4,0xF4,0xF4,0xF4,    
0x74,0x40,0x74,0xF0,0x74,0x74,0x74,0x74,    
0xF1,0x71,0xF1,0xF1,0xF1,0x15,0xF1,0x15,    
0x47,0x47,0x47,0x47,0x74,0x74,0x74,0xF4,    
0x7F,0x7F,0x17,0x1F,0x10,0xF1,0xF1,0xF1,    
0xF4,0xF4,0xF0,0xF4,0xF4,0xF4,0x14,0xF0,    
0x14,0xF4,0x4F,0x40,0x14,0x40,0x14,0xF0,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF1,0xF1,0xF1,    
0xE4,0xF4,0xF4,0x14,0x14,0x14,0xF4,0x1F,    
0x74,0x40,0xF0,0x40,0x14,0x40,0x14,0xF0,    
0xF4,0xF4,0x4F,0xF4,0xF4,0xF4,0xF4,0x1F,    
0xF4,0xF4,0x4F,0x14,0x14,0x14,0x41,0xF0,    
0x74,0xF4,0x4F,0x40,0x74,0x40,0x40,0xF0,    
0xF4,0xF4,0x14,0xF4,0xF4,0xF4,0xF4,0xF0,    
0xF4,0xF4,0x4F,0x40,0x40,0x40,0x40,0xF0,    
0x15,0x17,0x15,0x15,0x15,0x15,0x14,0x1F,    
0x10,0xF1,0x15,0x15,0x74,0xF4,0xF4,0xF4,    
0x10,0xF0,0x40,0x40,0x40,0x40,0xF0,0x40,    
0x10,0x1F,0x14,0xF4,0xF4,0xF4,0x4F,0xF4,    
0x10,0x1F,0xF4,0x40,0x40,0x74,0xF4,0xF4,    
0x10,0xF0,0x40,0x40,0x14,0x40,0xF0,0x40,    
0x10,0x1F,0xF1,0xF4,0xF4,0xF4,0x4F,0xF4,    
0x10,0xF0,0x40,0x40,0x14,0x40,0x4F,0xF4,    
0x10,0xF0,0x40,0x40,0x14,0x40,0xF0,0x40,    
0x10,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,    
0x10,0xF1,0xF1,0x14,0xF4,0xF4,0xF4,0xF4,    
0x10,0xF1,0xF1,0xF4,0xF4,0xF4,0xF4,0xF4,    
0x10,0x1F,0xF1,0x4F,0xF1,0x4F,0xF1,0x4F,    
0x10,0xF1,0xF1,0x14,0xF4,0xF4,0xF4,0xF4,    
0x10,0xF0,0x14,0x40,0x14,0x40,0xF0,0x40,    
0x10,0x1F,0xF1,0xF4,0xF4,0xF4,0x4F,0xF4,    
0x10,0x1F,0xF4,0x14,0x14,0x40,0xF4,0xF4,    
0x10,0xF0,0x14,0x14,0x14,0x14,0xF0,0x14,    
0x10,0xF0,0x14,0x40,0x41,0x40,0x4F,0xF4,    
0x10,0xF0,0x14,0x40,0x41,0x40,0xF0,0x14,    
0x10,0xF1,0xF1,0xF1,0xF4,0xF4,0xF1,0xF4,    
0x10,0x1F,0xF4,0x4F,0xF4,0x4F,0xF4,0x1F,    
0x74,0x17,0x17,0x17,0xF1,0xF0,0xF7,0xF7,    
0x4F,0xF4,0x74,0x40,0x74,0x4F,0x74,0x74,    
0x74,0x74,0x47,0x47,0x47,0x47,0x47,0x47,    
0x7F,0x47,0x74,0x47,0x74,0xF7,0x47,0x47,    
0xF0,0x40,0x40,0x40,0x40,0xF0,0x74,0x74,    
0x7F,0xF7,0x47,0xF7,0x47,0x7F,0x47,0x47,    
0x4F,0xF4,0xF4,0xF4,0x47,0x7F,0x74,0x47,    
0x4F,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0x17,0x17,0x17,0x47,0x17,0x47,0x47,0xF7,    
0xF4,0xF4,0x74,0x74,0xF4,0xF4,0x74,0x74,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0xF1,0xF1,0xF1,0x41,0xF1,0x41,0x14,0x14,    
0xF4,0xF4,0x14,0x14,0xF1,0xF0,0xF4,0xF4,    
0x4F,0xF4,0x40,0x40,0x40,0x4F,0x40,0x40,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0x4F,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0xF0,0x40,0x14,0x40,0x14,0xF0,0x14,0x40,    
0x4F,0xF4,0xF4,0xF4,0xF4,0x4F,0xF4,0xF4,    
0x4F,0xF4,0xF4,0xF4,0xF4,0x4F,0xF4,0xF4,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,    
0xF4,0xF4,0xE4,0xF4,0xE4,0xF4,0xF4,0xF4,    
0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0x14,    
0x10,0xF1,0x17,0x17,0x17,0x17,0xF7,0xF7,    
0x10,0xF0,0x74,0x47,0x74,0x47,0xF0,0x47,    
0x10,0x1F,0x14,0xF4,0xF4,0xF4,0x7F,0x47,    
0x10,0x1F,0x47,0x47,0x47,0x47,0xF7,0x47,    
0x10,0xF0,0x74,0x47,0x74,0x74,0xF0,0x74,    
0x10,0x1F,0xF4,0x74,0x47,0x47,0x7F,0x47,    
0x10,0xF0,0x74,0x47,0x47,0x47,0x7F,0x47,    
0x10,0xF0,0x74,0x74,0x74,0x74,0xF0,0x74,    
0x10,0xF1,0xF1,0x71,0xF1,0x71,0xF1,0xE1,    
0x10,0xF1,0x71,0x17,0x74,0x47,0x47,0xF7,    
0x10,0x1F,0xF4,0x4F,0xF4,0x4F,0xF4,0x4F,    
0x17,0x17,0x17,0x17,0x17,0xF0,0xF7,0xF7,    
0x7F,0xF7,0x70,0x70,0x70,0x7F,0x70,0x70,    
0x47,0x47,0x47,0xF7,0x47,0xF7,0xF7,0xF7,    
0x7F,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,    
0xF0,0x47,0x47,0x47,0x47,0xF0,0x47,0x47,    
0x7F,0xF7,0xF7,0xF7,0xF7,0x7F,0x74,0x47,    
0x7F,0xF7,0xF7,0xF7,0xF7,0x7F,0xF7,0xF7,    
0x7F,0x47,0x47,0x47,0x47,0x47,0x47,0x47,    
0x17,0x17,0x17,0x17,0x47,0x17,0xF7,0xF7,    
0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,    
0x74,0x47,0x74,0x47,0x74,0x47,0x47,0x47,    
0xF1,0x71,0xF1,0x51,0x51,0x51,0x15,0x17,    
0x10,0xF1,0x17,0x17,0x74,0x47,0x47,0xF4,    
0x10,0xF0,0x70,0x70,0x47,0x70,0xF0,0x70,    
0x10,0x1F,0x17,0x17,0xF7,0xF7,0x4F,0x47,    
0x10,0x1F,0xF7,0x70,0x47,0x47,0xF4,0xF7,    
0x10,0xF0,0x70,0x70,0x47,0x70,0xF0,0x70,    
0x10,0x1F,0x17,0x17,0xF7,0xF7,0x4F,0x47,    
0x10,0xF0,0x57,0x70,0x47,0x70,0x7F,0xF7,    
0x10,0xF0,0x70,0x70,0x70,0x70,0xF0,0x70,    
0x10,0xF1,0x71,0x71,0x71,0x71,0xF1,0xF1,    
0x10,0xF1,0x17,0x17,0x17,0xF7,0xF7,0xF7,    
0x10,0xF1,0x1E,0x17,0xF7,0xF7,0xF7,0xF7,    
0xF4,0xF4,0x15,0x14,0xF1,0xF0,0xF4,0xF4,    
0x7F,0x74,0x74,0x47,0x74,0x7F,0x74,0x74,    
0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,    
0x4F,0xF4,0x74,0xF4,0x74,0xF4,0xF4,0xF4,    
0xF0,0x47,0x47,0x70,0x47,0xF0,0x47,0x47,    
0x4F,0xF4,0xF4,0x4F,0xF4,0x4F,0x47,0x47,    
0x4F,0xF7,0xF4,0x47,0x47,0x4F,0x47,0xF4,    
0x7F,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,    
0xF4,0x74,0x17,0x74,0xF4,0x74,0xF4,0xF4,    
0x74,0x47,0x47,0x74,0xF4,0xF4,0x74,0xF4,    
0xF7,0xF7,0xF7,0xF7,0x47,0xF7,0xF7,0xF7,    
0x71,0x71,0x71,0x71,0x71,0x71,0x17,0x17,    
0x10,0xF1,0x15,0x14,0xF4,0xF4,0xF4,0xF4,    
0x10,0xF0,0x74,0x40,0x74,0x74,0xF0,0x40,    
0x10,0x1F,0x17,0x17,0x74,0x47,0x4F,0x74,    
0x10,0x1F,0xF4,0x74,0x74,0x40,0xF4,0xF4,    
0x10,0xF0,0x74,0x74,0x74,0x74,0xF0,0x74,    
0x10,0x1F,0x17,0x47,0x74,0x47,0x4F,0x47,    
0x10,0xF0,0x74,0x40,0x74,0x40,0x4F,0xF4,    
0x10,0xF0,0x74,0x74,0x74,0x74,0xF0,0x74,    
0x10,0xF1,0x71,0x71,0xF1,0x71,0xF1,0xE1,    
0x10,0xF1,0x71,0x15,0xF4,0xF4,0xF4,0xF4,    
0x10,0xF1,0xF1,0x17,0xF7,0xF7,0x74,0x47,    
0x10,0x1F,0x17,0x7F,0xF7,0x7F,0xF7,0x7F,    
0xF4,0xF4,0x41,0x14,0xF1,0xF0,0xF4,0xF4,    
0x4F,0xF4,0xF4,0xF4,0xE4,0xF4,0xE4,0xF4,    
0xF0,0x74,0x74,0x40,0x74,0xF0,0x74,0x40,    
0x4F,0xF4,0x74,0xF4,0x74,0xF4,0xF4,0xF4,    
0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xE4,0xF4,    
0x74,0xF4,0x74,0xF4,0x74,0xF4,0xF4,0xF4,    
0x71,0x71,0x71,0x71,0x71,0x51,0x17,0x15
};

const unsigned char PAT0[] = {
/*   
// ***************************************
// Character Patterns                    
// ***************************************
*/
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,    
0x2B,0x19,0x2B,0x84,0x2A,0x84,0x2B,0x82,    
0xFF,0xFF,0xFF,0xC0,0xFF,0xFF,0xFF,0xFF,    
0x05,0x06,0x05,0x03,0x03,0x3C,0x1D,0x0C,    
0x10,0x10,0x10,0x11,0x10,0xB0,0x2B,0x27,    
0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,    
0x15,0x1A,0x10,0x0F,0x70,0x70,0x70,0x70,    
0x80,0x80,0x80,0x78,0x84,0x84,0x84,0x84,    
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,    
0x41,0x41,0x43,0xC2,0x43,0x38,0x47,0x38,    
0x03,0x04,0x04,0x04,0x08,0x08,0x08,0x10,    
0x02,0x82,0x81,0x81,0x41,0x40,0x40,0x20,    
0x4A,0x86,0x82,0x03,0xFF,0x80,0x80,0x80,    
0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x82,    
0x8A,0xFF,0x0A,0xC0,0x08,0xFF,0x02,0xFF,    
0x04,0x04,0x04,0x03,0x03,0x3C,0x1C,0x0C,    
0x10,0x10,0x10,0x11,0x10,0x10,0x10,0x10,    
0xA8,0x01,0x55,0xFF,0x08,0x40,0x2A,0xFF,    
0x10,0x10,0x10,0x0F,0x70,0x70,0x70,0x70,    
0x8A,0xFF,0x55,0xFF,0x88,0xFF,0x55,0xFF,    
0x41,0x41,0x42,0xC2,0x42,0x38,0x44,0x38,    
0x02,0x82,0x81,0x81,0x41,0x40,0x40,0x20,    
0x4A,0x86,0x82,0x03,0xFF,0x80,0x80,0x80,    
0x80,0x80,0xFF,0x80,0x80,0x80,0x80,0xFF,    
0x54,0x1C,0x01,0x0F,0x55,0x05,0x2B,0xFF,    
0x78,0x07,0x07,0x0A,0x0B,0x4E,0x60,0x80,    
0x8A,0x08,0x07,0xFF,0x0A,0xFF,0xC0,0xC0,    
0x40,0x20,0xFF,0xFF,0x50,0xA0,0x54,0xFF,    
0xE0,0xE0,0x07,0xE0,0xE0,0x17,0x13,0x0F,    
0x2A,0x60,0xE0,0x13,0x8A,0x01,0x0A,0xFF,    
0x08,0x08,0x07,0x80,0x40,0x20,0x50,0xFF,    
0x88,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,0xFF,    
0x2B,0x0D,0x70,0x17,0x18,0x18,0x38,0xFF,    
0x04,0x04,0x03,0xFF,0xFF,0xFF,0x40,0xFF,    
0x70,0x07,0x07,0x07,0x03,0x03,0x03,0x03,    
0x2B,0x1D,0xFF,0x0F,0x2A,0x07,0x2A,0xFF,    
0xFF,0x01,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,    
0x84,0x06,0x05,0x0A,0x0B,0x11,0x60,0x80,    
0x10,0x08,0x07,0xA0,0x50,0x80,0xC0,0xC0,    
0x08,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,    
0x15,0x1A,0x07,0x18,0xE0,0x14,0x13,0x0F,    
0x80,0x60,0xE0,0xFF,0x40,0x20,0x50,0xFF,    
0x08,0x08,0x07,0x01,0x08,0xFF,0xFF,0xFF,    
0x54,0x72,0x15,0x39,0x15,0xC4,0x15,0xFF,    
0x80,0x80,0x70,0x08,0x18,0x18,0x38,0xFF,    
0x04,0x04,0x03,0xFF,0x08,0xFF,0x02,0xFF,    
0x10,0x07,0x58,0x07,0x5C,0x03,0x5C,0x03,    
0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x82,    
0x55,0x01,0x0A,0xC0,0x0A,0xFF,0x02,0xFF,    
0x47,0x07,0x47,0x03,0x03,0x3C,0x1D,0x0C,    
0x10,0x10,0x10,0x11,0x10,0x10,0x10,0x10,    
0x54,0x1E,0x55,0xFF,0x55,0x78,0x2A,0x3C,    
0xE0,0xE0,0xE0,0x0F,0x70,0x70,0x70,0x70,    
0x0A,0x07,0x02,0x78,0x84,0x84,0x84,0x84,    
0x55,0x78,0x55,0xFF,0x55,0x3C,0x55,0x1E,    
0x41,0x41,0x3C,0x3C,0x43,0x38,0x38,0x38,    
0x03,0x04,0x0A,0x04,0x08,0x08,0x08,0x10,    
0x02,0x82,0x81,0x81,0x41,0x17,0x40,0x15,    
0x28,0x64,0xFF,0x70,0x2A,0x58,0x2A,0xFF,    
0x80,0x01,0x01,0xFF,0x80,0xFF,0x80,0xFF,    
0x2A,0x04,0x0B,0x04,0x04,0x0E,0xE0,0x80,    
0xA8,0x08,0x07,0x50,0x88,0xC0,0xC0,0xC0,    
0x08,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,    
0x55,0xC8,0x07,0x18,0x18,0x6A,0x0C,0x0F,    
0x80,0x60,0xE0,0xFF,0xA8,0xFF,0xA0,0xFF,    
0x02,0x07,0x07,0x03,0x08,0x01,0xFF,0xFF,    
0x55,0x40,0x45,0x0F,0x55,0x23,0x55,0xFF,    
0x80,0x80,0x70,0x08,0x18,0x18,0x38,0xFF,    
0x8A,0x04,0x03,0x01,0x0A,0xFF,0x02,0xFF,    
0x0F,0x07,0x27,0x07,0x03,0x03,0x2B,0x03,    
0x68,0x84,0x6A,0x84,0x84,0x84,0x84,0x82,    
0x88,0xFF,0xA0,0xC0,0xA8,0xFF,0xA8,0x40,    
0x0A,0x03,0x03,0x03,0x03,0x3C,0x5C,0x03,    
0x17,0xC4,0x55,0x11,0x15,0xC8,0x15,0x1B,    
0x08,0xFF,0xFF,0xFF,0x80,0xFF,0x80,0xFF,    
0x8A,0x0F,0x0A,0x0F,0x70,0x70,0x70,0x0F,    
0x80,0x80,0x28,0x78,0x84,0x60,0x2A,0x70,    
0xFF,0xFF,0xFF,0xFF,0x08,0xFF,0xFF,0xFF,    
0x41,0xC1,0x3C,0xC2,0x3C,0x38,0x3A,0x38,    
0x03,0x04,0xA0,0x04,0xA0,0xC0,0xA0,0xE0,    
0x02,0x82,0x81,0x81,0x41,0x40,0x40,0x20,    
0x4A,0x86,0x29,0x03,0xFF,0x80,0x80,0x80,    
0x80,0x80,0xFF,0x80,0x80,0x80,0x80,0xFF,    
0x15,0x01,0x01,0xFF,0x05,0x02,0x05,0xFF,    
0x0B,0x43,0x5C,0x05,0x5A,0x0E,0x60,0x80,    
0x10,0x08,0x07,0xFF,0xFF,0xFF,0xC0,0xC0,    
0xA8,0x1B,0xFF,0x0F,0x55,0x27,0x15,0xFF,    
0x0F,0x0F,0x07,0x07,0x78,0x0B,0x0C,0x0F,    
0x85,0x60,0xE0,0xFF,0x01,0xFF,0xFF,0xFF,    
0xA0,0x08,0x07,0xC0,0xA8,0x1B,0x55,0xFF,    
0x40,0xC0,0xC0,0xC1,0xC1,0xC1,0xC1,0xFF,    
0x6A,0x80,0x70,0x08,0x18,0x18,0x38,0xFF,    
0xA8,0x04,0x03,0x80,0xA8,0x40,0xA8,0xFF,    
0x0F,0x07,0x07,0x07,0x03,0x03,0x03,0x03,    
0x01,0xFF,0x01,0xC0,0xFF,0xFF,0xFF,0xFF,    
0x54,0x1C,0x54,0x03,0x03,0x3C,0x1C,0x0C,    
0x41,0x21,0x50,0xFF,0x10,0x20,0x14,0xFF,    
0x50,0x0F,0x50,0x0F,0x70,0x70,0x70,0x70,    
0x85,0x80,0x80,0x78,0x84,0x84,0x84,0x84,    
0x05,0xFF,0x05,0xFF,0x41,0x02,0x41,0x80,    
0x41,0xC1,0x42,0xC2,0x42,0x38,0x44,0x38,    
0xA8,0x50,0x2A,0x78,0x55,0x63,0x55,0x20,    
0x4A,0x86,0x01,0x03,0xFF,0x80,0x80,0x80,    
0x80,0x80,0xFF,0x80,0x80,0x80,0x2A,0xFF,    
0x88,0x01,0x01,0xFF,0x88,0xFF,0xA8,0xFF,    
0x84,0x04,0x04,0x0A,0x0A,0x11,0x60,0x80,    
0x10,0x08,0x07,0x50,0x88,0x40,0xC0,0xC0,    
0x01,0xFF,0xFF,0xFF,0x80,0xFF,0x80,0xFF,    
0x10,0x10,0x07,0x18,0x18,0x14,0x13,0x0F,    
0x80,0x60,0xE0,0x40,0x88,0x40,0x55,0xFF,    
0x0D,0x08,0x07,0xFF,0x01,0xFF,0xFF,0xFF,    
0x40,0x40,0x2A,0x01,0x01,0x01,0x01,0xFF,    
0x04,0x04,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,    
0x0F,0x07,0x07,0x07,0x03,0x03,0x03,0x03,    
0xFF,0x07,0xE0,0xC0,0x50,0x40,0x81,0x82,    
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,    
0xFF,0x03,0x23,0x05,0x06,0x06,0x03,0x04,    
0xFF,0xC0,0xC0,0xFF,0xFF,0x80,0x07,0x08,    
0xFF,0xFF,0xFF,0xFF,0x02,0xFF,0xFF,0xFF,    
0xFF,0x0F,0x13,0x14,0x18,0x18,0x0F,0x10,    
0xFF,0xFF,0xFF,0xFF,0x08,0xFF,0xE0,0x60,    
0xFF,0xFF,0xFF,0xFF,0x08,0xFF,0xFF,0xFF,    
0xFF,0xC0,0x40,0x40,0x40,0x40,0xC0,0x41,    
0xFF,0x07,0x18,0xC0,0x40,0x80,0x80,0x03,    
0xFF,0x80,0x61,0x12,0x0E,0x06,0x06,0x02,    
0xFF,0x03,0x02,0x86,0x85,0x4A,0x85,0x52,    
0xFF,0x07,0x18,0xC0,0x40,0x40,0x81,0x82,    
0xFF,0xFF,0x0A,0xFF,0x8A,0xFF,0xFF,0xFF,    
0xFF,0x03,0x04,0x05,0x06,0x06,0x03,0x04,    
0xFF,0xC0,0xC0,0x05,0x08,0xFF,0x07,0x08,    
0xFF,0xFF,0x0A,0x01,0x8A,0x04,0xFF,0x01,    
0xFF,0xFF,0x28,0xFF,0x55,0xFF,0xE0,0x60,    
0xFF,0xFF,0x2A,0xFF,0x55,0xFF,0xFF,0x01,    
0xFF,0x80,0x61,0x12,0x0E,0x06,0x06,0x02,    
0xFF,0x03,0x02,0x86,0x85,0x4A,0x85,0x52,    
0x55,0x80,0xC0,0xC0,0x1D,0xFF,0x80,0x80,    
0x01,0x01,0x40,0xFF,0x50,0x0F,0x50,0xC0,    
0x0F,0x07,0x78,0x78,0x78,0x78,0x78,0x78,    
0xE0,0x4D,0x55,0x07,0x55,0x11,0x2B,0x03,    
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x40,0x80,    
0x0F,0x70,0x82,0x70,0x8A,0x0F,0xE0,0xE0,    
0x78,0x84,0x84,0x84,0x2B,0x78,0xC4,0x0F,    
0x07,0x08,0x08,0x08,0x08,0x08,0x08,0x08,    
0xB0,0xB0,0xB0,0xA1,0xA0,0xA0,0x82,0x60,    
0x10,0x10,0x70,0xA0,0x23,0x43,0x54,0xE0,    
0x20,0x20,0x10,0x10,0x10,0x08,0x08,0x08,    
0x40,0x40,0x40,0xE0,0x20,0xE0,0x0F,0x0F,    
0x41,0x40,0xC0,0xC0,0x1D,0xFF,0x80,0x80,    
0x01,0x01,0xFF,0xFF,0xFF,0x0F,0xFF,0xFF,    
0x0C,0x04,0x84,0x84,0x84,0x84,0x84,0x84,    
0xE0,0x10,0x10,0x10,0x10,0x11,0x10,0x10,    
0xFF,0xFF,0x0A,0xFF,0x0A,0xFF,0x02,0xFF,    
0x0F,0x70,0x70,0x70,0x70,0x0F,0x10,0x10,    
0x78,0x84,0x84,0x84,0x84,0x78,0x80,0x80,    
0x48,0x48,0x48,0x50,0x50,0x50,0x60,0x60,    
0x10,0x10,0x20,0x20,0x23,0x43,0x40,0x40,    
0x20,0x20,0x10,0x10,0x10,0x08,0x08,0x08,    
0x40,0x40,0x40,0x20,0x20,0x20,0x10,0x0F,    
0xFF,0x07,0xE0,0xC0,0x80,0x80,0x81,0x82,    
0xFF,0xFF,0x54,0x0F,0x55,0x07,0xFF,0x03,    
0xFF,0x03,0x03,0x05,0x07,0x06,0x03,0x78,    
0xFF,0xC0,0x0A,0x0F,0x0A,0x05,0x07,0x03,    
0xFF,0xFF,0x50,0x0F,0x50,0x78,0xFF,0x3C,    
0xFF,0x0F,0x13,0x17,0xE0,0xE0,0x0F,0xE0,    
0xFF,0xFF,0x55,0x78,0x2A,0x1C,0xE0,0x1E,    
0xFF,0xFF,0x50,0x80,0x54,0xA0,0xFF,0xE0,    
0xFF,0xC0,0x40,0xC0,0x40,0xC0,0xC0,0xC1,    
0xFF,0x07,0x1D,0xC0,0x51,0x03,0x2A,0x03,    
0xFF,0x03,0x02,0x86,0x85,0x4A,0x85,0x52,    
0x80,0x80,0xC0,0xC0,0xE0,0xFF,0x80,0x80,    
0x01,0x01,0xFF,0xFF,0xFF,0x0F,0xFF,0xFF,    
0xA0,0x18,0x2A,0x84,0x2A,0x84,0x84,0x84,    
0xE0,0x10,0x10,0x10,0x10,0x11,0x10,0x10,    
0xFF,0x1E,0x0A,0x07,0x0A,0xFF,0x02,0x03,    
0x0F,0x70,0x70,0x70,0x70,0x0F,0x55,0xC0,    
0x78,0x84,0x84,0x84,0x84,0x78,0x80,0x80,    
0x07,0x54,0x22,0x30,0xA2,0x14,0x02,0x06,    
0xB0,0x30,0x30,0x20,0xA8,0x20,0x60,0x60,    
0x10,0x10,0x20,0x20,0x23,0x43,0x40,0x40,    
0x70,0x0D,0x55,0x07,0x55,0x03,0x22,0x01,    
0x40,0xC0,0x40,0xE0,0xE0,0xE0,0x0F,0x0F,    
0xFF,0x07,0xE0,0xC0,0x55,0x98,0x2A,0x82,    
0xFF,0xFF,0xFF,0xFF,0x80,0xFF,0xFF,0xFF,    
0xFF,0x03,0x03,0x02,0x06,0x06,0x03,0x03,    
0xFF,0xC0,0xC0,0xFF,0xA8,0x80,0x07,0x08,    
0xFF,0xFF,0xFF,0xFF,0x08,0xFF,0xFF,0xFF,    
0xFF,0x0F,0x0C,0x08,0x18,0x18,0x0F,0x06,    
0xFF,0xFF,0x80,0xFF,0x80,0xFF,0xE0,0x60,    
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,    
0xFF,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC1,    
0xFF,0x07,0xE0,0xC0,0x80,0x80,0x80,0x03,    
0xFF,0x80,0x1E,0x0C,0x0E,0x06,0x06,0x02,    
0x41,0x40,0xC0,0xC0,0x1D,0xFF,0x80,0x80,    
0x01,0x1B,0x55,0x70,0x55,0x0F,0x55,0x03,    
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,    
0xE0,0x10,0x15,0x10,0x15,0x11,0x10,0x10,    
0xFF,0x40,0xA0,0xFF,0xA8,0xFF,0xA8,0x40,    
0x0F,0x70,0x70,0x0F,0x70,0x0F,0x0F,0x0F,    
0x78,0x84,0x84,0x50,0x6A,0x78,0x6A,0x80,    
0x07,0x08,0x08,0x08,0x08,0x08,0x08,0x08,    
0x48,0xC8,0x32,0xD0,0x50,0xD0,0x60,0xE0,    
0x55,0xC0,0x8A,0x27,0x23,0x43,0x55,0x40,    
0x20,0x20,0x10,0x10,0x80,0x08,0x08,0x08,    
0xC0,0xC0,0xC0,0xE0,0xE0,0xE0,0x0F,0x0F,    
0xFF,0x07,0xE0,0xC0,0x40,0x40,0x81,0x82,    
0xFF,0xFF,0x15,0xFF,0x05,0x02,0xFF,0xFF,    
0xFF,0x03,0x03,0x02,0x56,0x81,0x03,0x3C,    
0xFF,0xC0,0xC0,0x02,0x05,0xFF,0x07,0x08,    
0xFF,0xFF,0x05,0x0F,0x05,0x07,0xFF,0x83,    
0xFF,0x0F,0x0C,0x0B,0x78,0x07,0x0F,0x0F,    
0xFF,0xFF,0x50,0xFF,0x14,0xFF,0xE0,0x60,    
0xFF,0xFF,0x55,0x07,0x15,0x23,0xFF,0x09,    
0xFF,0xC0,0xC0,0xC0,0x40,0xC0,0xC0,0xC1,    
0xFF,0x07,0x1D,0xC0,0x40,0x80,0x80,0x03,    
0xFF,0x80,0x61,0x0C,0x0E,0x06,0x17,0x60,    
0xFF,0x03,0x01,0x86,0x85,0x4A,0x85,0x52,    
0x41,0x40,0x35,0xC0,0x1C,0xFF,0x80,0x80,    
0xE0,0x10,0x10,0x10,0x10,0x11,0x10,0x10,    
0xFF,0x02,0x05,0xFF,0x05,0xFF,0x01,0xFF,    
0x07,0x08,0x58,0x08,0x1C,0x08,0x08,0x08,    
0x10,0x10,0x20,0x20,0x23,0x43,0x40,0x40,    
0x35,0x20,0x15,0x10,0x15,0x08,0x08,0x08,    
0xC0,0xC0,0xC0,0xE0,0x60,0xE0,0x0F,0x0F
};

const unsigned char MD0[] ={
/*
// ***************************************
// Map Data                              
// ***************************************
*/
// -- Map Row 1 --                       
0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,    
0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,0x80,0x81,    
0x82,0x77,0x83,0x84,0x7A,0x7B,0x85,0x86,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 2 --                       
0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,    
0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,    
0x11,0x12,0x07,0x13,0x14,0x0A,0x15,0x16,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 3 --                       
0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,    
0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,    
0x97,0x98,0x99,0x8E,0x9A,0x9B,0x9C,0x9D,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 4 --                       
0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,    
0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,    
0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 5 --                       
0x9E,0x9F,0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,    
0xA6,0xA7,0x7C,0xA8,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 6 --                       
0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,    
0x37,0x38,0x39,0x0C,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 7 --                       
0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,    
0xB1,0xB2,0xB3,0xB4,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 8 --                       
0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,    
0x42,0x43,0x44,0x45,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 9 --                       
0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,    
0xBD,0xBE,0xBF,0xA8,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 10 --                      
0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,    
0x4E,0x4F,0x50,0x51,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 11 --                      
0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,    
0xC8,0xC9,0xCA,0xCB,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 12 --                      
0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,    
0x5A,0x5B,0x5C,0x5D,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 13 --                      
0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,    
0xD4,0xD5,0xD6,0xD7,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 14 --                      
0x0D,0x5E,0x5F,0x10,0x60,0x61,0x62,0x63,    
0x64,0x0A,0x65,0x66,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 15 --                      
0xD8,0x94,0x95,0xD9,0xDA,0x98,0x99,0xDB,    
0x9A,0xDC,0xDD,0xDE,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
// -- Map Row 16 --                      
0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,    
0x6F,0x2C,0x70,0x71,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

/*
// as listed, characters from 64 to 85 only (alphabet)
// space is @, period is H, and Q is Y. Not available:
// H,J,K,V,W,X,Z
// HAND EDITED FOR LABELS, SO THEY DON'T CONFLICT
*/
const unsigned char CLIC64[] = {
/*
// ***************************************
// CLICorset Definitions                  
// ***************************************
*/
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,    
0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x10,    
0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x10,    
0x1F,0x1F,0x1F,0xF1,0x1F,0x1F,0x1F,0x10,    
0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x10,    
0x1F,0xF1,0xF1,0x1F,0xF1,0xF1,0x1F,0x10,    
0x1F,0xF1,0xF1,0x1F,0xF1,0xF1,0xF1,0x10,    
0x1F,0x1F,0xF1,0x1F,0x1F,0x1F,0x1F,0x10,    
0x10,0x10,0x10,0x10,0x10,0xF1,0xF1,0x10,    
0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0x10,    
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,    
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,    
0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0x1F,0x10,    
0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x10,    
0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x10,    
0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x10,    
0x1F,0x1F,0x1F,0x1F,0xF1,0xF1,0xF1,0x10,    
0x1F,0x1F,0x1F,0xF1,0xF1,0xF1,0xF1,0x10,    
0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x10,    
0x1F,0x1F,0xF1,0x1F,0xF1,0x1F,0x1F,0x10,    
0x1F,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0x10,    
0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x10
};

const unsigned char PLIC64[] = {
/****************************************
// Character PLICterns                    
// ***************************************/
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,    
0x83,0x39,0x39,0x39,0x01,0x39,0x39,0xFF,    
0x03,0x39,0x39,0x03,0x39,0x39,0x03,0xFF,    
0x01,0x39,0x39,0xC0,0x39,0x39,0x01,0xFF,    
0x03,0x39,0x39,0x39,0x39,0x39,0x03,0xFF,    
0x01,0xC0,0xC0,0x03,0xC0,0xC0,0x01,0xFF,    
0x01,0xC0,0xC0,0x03,0xC0,0xC0,0xC0,0xFF,    
0x01,0x39,0xC0,0x31,0x39,0x39,0x01,0xFF,    
0xFF,0xFF,0xFF,0xFF,0xFF,0x60,0x60,0xFF,    
0x38,0x38,0x38,0x38,0x38,0x38,0x38,0xFF,    
0x00,0x04,0x04,0x04,0x04,0x04,0x44,0x38,    
0x00,0x44,0x48,0x50,0x60,0x50,0x48,0x44,    
0x60,0x60,0x60,0x60,0x60,0x60,0x81,0xFF,    
0x39,0x11,0x01,0x29,0x39,0x39,0x39,0xFF,    
0x39,0x19,0x09,0x21,0x31,0x39,0x39,0xFF,    
0x01,0x39,0x39,0x39,0x39,0x39,0x01,0xFF,    
0x01,0x39,0x39,0x01,0xC0,0xC0,0xC0,0xFF,    
0x39,0x39,0x39,0x6C,0x38,0x38,0x38,0xFF,    
0x01,0x39,0x39,0x03,0x39,0x39,0x39,0xFF,    
0x01,0x39,0xC0,0x01,0x06,0x39,0x01,0xFF,    
0x01,0x38,0x38,0x38,0x38,0x38,0x38,0xFF,    
0x39,0x39,0x39,0x39,0x39,0x39,0x01,0xFF
}; 

// output string (inset by 4):
const unsigned char LICTXT[] = {
"    NOT@LICENSED@OR@ENDORSED    "
"    BQ@SEGA@ENTERPRISES@LTDH    "
};

// registers for bitmap (and 5B00 is the address of the sprite table)
// background is black. 
// PDT - 0x0000
// SIT - 0x1800
// SDT - 0x1800
// CT  - 0x2000
// SAL - 0x1B00
const unsigned char BMREGS[] = {
0x81,0xA2,0x80,0x02,0x82,0x06,0x83,0xff,0x84,0x03,0x85,0x36,0x86,0x03,0x87,0x01,0x5B,0x00,0x00,0x00
};

// LOADRG - load regs list to VDP address, end on 0x00,0x00, and 
// write 0xD0 (for sprites) (so second to last entry is write address for sprite table)
void LOADRG(unsigned char *pDat) {
    unsigned int val;
    
    for (;;) {
        val=(*(pDat++))<<8; // big endian data
        val|=*(pDat++);
        if (!val) break;
        VDP_SET_ADDRESS(val);
    }
    VDPWD = 0xd0;   // sprite table
}

// wait r4 jiffies - warning: changes banked page
void delay(unsigned char time) {
    do {
        vdpwaitvint();
        if (0 != SongBank) {
            SWITCH_IN_BANK(SongBank);
            CALL_PLAYER_SN;
        }
        if (time) --time;
    } while(time);
}

	
void main() {
    SongBank = 0;   // for delay to be safe
    
// BITMAP - Setup for bitmap mode as a character display, all characters set to 0
// returns with video off - set VDP R1 to E2 to enable (0x81,0xE2,)
// do it inline cause the library isn't set up the same way
    LOADRG(BMREGS);
	
// set up SIT - we just clear it to 0 (instead of the normal bitmap setup, 
// we are going to treat as a character display)
    vdpmemset(0x1800, 0, 768);

// first just need to initialize the space character to be black (color table only)
    vdpmemset(0x2000, 0x11, 8);

// Now load the SEGA character and color data into the middle table (includes a space)
    vdpmemcpy(0x800, PAT0, 223*8);
    vdpmemcpy(0x2800, COL0, 223*8);

// into the bottom table, we zero out the 'space' again but add some characters for
// the unlicense warning
    vdpmemset(0x3000, 0x11, 8);
    vdpmemcpy(0x1000+64*8, PLIC64, 22*8);
	vdpmemcpy(0x3000+64*8, CLIC64, 22*8);
	
// now we can turn the screen on
    VDP_SET_ADDRESS(0x81e2);
	
// brief pause before the logo
    delay(0x30);
	
// we're going to sort of sloppily scroll the sega logo down
// I'm just going to do it in four steps for simplicity
// SIT is at 0x1800, and we need to start at row 10, col 10
    #define OUTR3 0x194a
	vdpmemcpy(OUTR3, MD0+3*(int)32, 12);
	
    delay(4);

    vdpmemcpy(OUTR3, MD0+2*(int)32, 12);
    vdpmemcpy(OUTR3+32, MD0+3*(int)32, 12);

    delay(4);

    vdpmemcpy(OUTR3, MD0+(1*(int)32), 12);
    vdpmemcpy(OUTR3+32, MD0+2*(int)32, 12);
    vdpmemcpy(OUTR3+64, MD0+3*(int)32, 12);

    delay(4);
	
    // now we're going to display the full frame 5 times with different
    // animation frames, ending on the first one
    {
        unsigned char r8=6;
        const unsigned char *r7=MD0-32;

        for (;;) {
            r7+=32;
            vdpmemcpy(OUTR3, r7, 12);
            vdpmemcpy(OUTR3+32, r7+32, 12);
            vdpmemcpy(OUTR3+64, r7+64, 12);
            vdpmemcpy(OUTR3+96, r7+96, 12);
            r7+=96;
            
            // display our disclaimer, both as a delay and as a to-be-nice
            vdpmemcpy(0x1800+22*(int)32, LICTXT, 64);

            delay(5);

            --r8;
            if (!r8) break;

            if (r8 == 2) r7=MD0+12-32;  // final new frame
            if (r8 == 1) r7=MD0-32;     // first frame
        }
    }

    // the copy is pretty darn fast for 24k, so to make the logo last a little
    // longer, we'll just pause for a second or so (also there is no copy here)
    delay(90);
    
    START();
}

// Thunder Force III Tribute music player
// 
// I first saw Thunder Force III back in 1987 or 1988, and have been hooked on it since.
// It's the reason I got a Sega Genesis, and I've always wanted my TI to do anything
// even remotely close. A major part of my vgmcomp2 music converter was wanting to
// be able to convert Genesis music, specifically for this sound track. So now, though
// I don't intend to do the whole game, I've used my conversion toolchains to do
// this little musical and graphical tribute.
// 
// There's a little over 64k of compressed music, and more than that in graphics, so
// there's a lot of bank switching. Each song fits in a single bank guaranteed, so
// that helps a lot. (That was 8k on the TI. We have 16k here, so we can double up a bit.)
// If I was ambitious, I'd put a player with each song bank, but I'm going to try
// to be naughty and just hack the player to read from the banks on the fly.

// bank definitions
#define tf3ti00 0xffe4
#define tf3ti01 0xffe5
#define tf3ti02 0xffe6
#define tf3ti03 0xffe7
#define tf3ti04 0xffe8
#define tf3ti05 0xffe9
#define tf3ti06 0xffea
#define tf3ti07 0xffeb
#define tf3ti08 0xffec
#define tf3ti09 0xffed
#define tf3ti10 0xffee
#define tf3ti11 0xffef
#define tf3ti12 0xfffc
#define tf3ti13 0xfffd
#define tf3ti14 0xfffe
#define mapbossunknown  0xfff0
#define mapbosscerberus 0xfff1
#define mapbossfish     0xfff2
#define mapbossfort     0xfff3
#define mapbossgargoyle 0xfff4
#define mapbosslobster  0xfff5
#define mapbossvulcan   0xfff6
#define mapbriefing     0xfff7
#define mapbriefingornbase 0xfff8
#define maptitlethird1  0xfff9
#define maptitlethird2  0xfffa
#define maptitlethird3  0xfffb

// memory allocation only, don't put initialized data here! It won't get loaded anyway!
	
// tf3 stuff
unsigned char SCRNBUF[11*(int)32]; // buffer used for mixing characters on the title page
unsigned char OLDKEY;   // remember last key pressed
unsigned char DEBOUNCEKEY; // current key for debounce
unsigned char DEBOUNCECNT; // current countdown for debounce

// briefing screen
signed int crosshairrow; 	 //		* current row of the crosshair in 8.8 fixed point
signed int crosshaircol;	 //		* current column of the crosshair in 8.8 fixed point
signed int crosshairspr; 	 //		* row speed of the crosshair in 8.8
signed int crosshairspc; 	 //		* column speed of the crosshair in 8.8
signed int crosshairtar; 	 //		* crosshair target row
signed int crosshairtac; 	 //		* crosshair target column
unsigned char weapon; 	 //			* current weapon (0 or 1)
unsigned char textline;  //		* current line being printed in display
unsigned char *textptr; 	 //		* pointer to next output char
unsigned int textvdp; 	 //			* VDP address of next output char
unsigned char textcount; 	 //		* number of characters left to print
unsigned char textdelay; 	 //		* delay frames left before next character
unsigned char statusline; 	 //		* index of status line for AID (0 = song title)
unsigned char statuscnt; 	 //		* countdown for automatically updating the status line
const unsigned char *nextsong; 	 //		* page of next song for tunes with two parts, 0 if none
unsigned char nextsongidx; 	 //	* index for the next song

// data
#define CHK32 0xFFe0

#if 1
void *memcpy (unsigned char *dst, const unsigned char *src, unsigned int count) {
    while (count--) {
        *(dst++) = *(src++);
    }
}
#else
void *memcpy(void *dest, const void *source, unsigned int count);
#endif

// ****************

// random data for displaying III
// generated in BLASSIC, 26 entries of y*(int)32+x+1
const unsigned char TITIII[] = {
    70,66,99,101,2,34,98,5,102,3,37,35,65,97,36,69,38,68,4,1,100,6,33,67,0
};

// ****************
// stage names are preceded by sprite coordinates (row,col) assuming just the world grid
// then always 6 characters of text
// For the sprite crosshairs, left is always the exact pixel, but specify right as
// desired minus 31, it's at the bottom of the mag 4 sprite
const char * const STAGESEL="STAGE SELECT";

struct _stagetxt {
    unsigned char row, col;
    unsigned char *pTxt;
};

const struct _stagetxt * const STAGETXT[5] = {
    &txthydra,&txtgorgon,&txtseiren,&txthaides,&txtellis
};

const struct _stagetxt txthydra = { 6,94,"HYDRA " };
const struct _stagetxt txtgorgon = { 57,166,"GORGON" };
const struct _stagetxt txtseiren = { 106,166,"SEIREN" };
const struct _stagetxt txthaides = { 106,103,"HAIDES" };
const struct _stagetxt txtellis = { 69,83,"ELLIS " };

// ****************
// text lines

const char * const txtstage  = "\x5STAGE";
const char * const txttarget  = "\x6TARGET";
const char * const txtduration  = "\x8\DURATION";

const unsigned char * const STATUSTEXT[] = {
    (const unsigned char*)0,
    "\x15MUSIC PLAYER BY TURSI",
    "\x13TFIII BY TECHNOSOFT",
    "\x13RIGHT FOR NEXT SONG",
    "\x16LEFT FOR PREVIOUS SONG",
    "\xf\ENJOY THE MUSIC",
    (const unsigned char*)0
};


// ****************
// Song information for the status screen
// 0 - status line, 1 - stage, 2 - Target, 3 - Duration, 4 - song 1 AND 2, crosshair row, crosshair col,portrait
// Song data is page, then index
struct _titleinfo {
    unsigned char l1;
    const unsigned char *t01 ;
    unsigned char l2;
    const unsigned char *t02 ;
    unsigned char l3;
    const unsigned char *t03 ;
    unsigned char l4;
    const unsigned char *t04 ;

    const unsigned char *s1 ;
    unsigned char idx1;
    const unsigned char *s2 ;
    unsigned char idx2;

    unsigned char row,col;
    const unsigned char *pic ;
};

const struct _titleinfo TITLEINFO = {
    26,"THE WIND BLEW ALL DAY LONG",
	5,"title",
	3,"tf3",
    4,"0m15",
    tf3ti00,0,0,0,
    0x2f,0x18,mapbossunknown
};

const struct _titleinfo SELECTINFO = {
	16,"BEYOND THE PEACE",
	6,"select",
	6,"choose",
	4,"1m01",
    tf3ti01,0,0,0,
	0x2f,0x18,mapbossunknown
};

const struct _titleinfo HYDRAINFO = {
	16,"BACK TO THE FIRE",
	5,"hydra",
	8,"gargoyle",
	4,"2m15",
    tf3ti02,0,0,0,
	0x16,0x1e,mapbossgargoyle
};

const struct _titleinfo HBOSSINFO = {
    8,"GARGOYLE",
	5,"hydra",
	8,"gargoyle",
	4,"1m38",
    tf3ti03,0,0,0,
	0x16,0x1e,mapbossgargoyle
};

const struct _titleinfo GORGONINFO = {
	10,"VENUS FIRE",
	6,"gorgon",
	11,"twin vulcan",
	4,"2m54",
    tf3ti00,5,0,0,
	0x49,0x66,mapbossvulcan
};

const struct _titleinfo GBOSSINFO = {
    11,"TWIN VULCAN",
    6,"gorgon",
    11,	"twin vulcan",
    4,	"1m11",
    tf3ti03,1,0,0,
	0x49,0x66,mapbossvulcan
};

const struct _titleinfo SEIRENINFO = {
    20,
    "THE GRUBBY DARK BLUE",
    6,
    "seiren",
    9,
    "king fish",
    4,
    "2m32",
    tf3ti04,0,0,0,
    0x7a,0x66,mapbossfish
};

const struct _titleinfo SBOSSINFO = {
9,
"KING FISH",
6,
"seiren",
9,
"king fish",
4,
"1m30",
tf3ti05,0,0,0,
0x7a,0x66,mapbossfish
};

const struct _titleinfo HAIDESINFO = {
5,
"TRUTH",
6,
"haides",
9,
"g lobster",
4,
"1m43",
tf3ti06,0,0,0,
0x7a,0x27,mapbosslobster,
};

const struct _titleinfo HABOSSINFO = {
9,
"G LOBSTER",
6,
"haides",
9,
"g lobster",
4,
"1m39",
tf3ti02,1,0,0,
0x7a,0x27,mapbosslobster
};

const struct _titleinfo ELLISINFO = {
19,
"FINAL TAKE A CHANCE",
5,
"ellis",
11,
"mobile fort",
4,
"1m41",
tf3ti04,1,0,0,
0x55,0x13,mapbossfort
};

const struct _titleinfo EBOSSINFO = {
11,
"MOBILE FORT",
5,
"ellis",
11,
"mobile fort",
4,
"1m03",
tf3ti01,2,0,0,
0x55,0x13,mapbossfort,
};

const struct _titleinfo CERBERUSINFO = {
31,
"HIS BEHAVIOUR INSPIRED DISTRUST",
8,
"cerberus",
8,
"cerberus",
4,
"5m16",
tf3ti05,1,tf3ti07,0,
0x36,0x33,mapbosscerberus,
};

const struct _titleinfo BASEINFO = {
26,
"HUNGER MADE THEM DESPERATE",
8,
"orn base",
7,
"no data",
4,
"3m51",
tf3ti08,0,0,0,
0x40,0x38,mapbossunknown
};

const struct _titleinfo BASEBOSSINFO = {
8,
"OFF LUCK",
8,
"orn base",
7,
"no data",
4,
"1m38",
tf3ti09,0,0,0,
0x40,0x38,mapbossunknown,
};

const struct _titleinfo COREINFO = {
12,
"FINAL MOMENT",
8,
"orn core",
6,
"cha os",
4,
"1m23",
tf3ti03,2,0,0,
0x49,0x3f,mapbossunknown
};

const struct _titleinfo ORNBOSSINFO = {
17,
"BE MENACED BY ORN",
6,
"cha os",
6,
"cha os",
4,
"1m49",
tf3ti00,1,tf3ti10,0,
0x49,0x3f,mapbossunknown
};

const struct _titleinfo STAGECLEARINFO = {
11,
"STAGE CLEAR",
5,
"clear",
9,
"destroyed",
4,
"0m02",
tf3ti00,2,0,0,
0x49,0x3f,mapbossunknown
};

const struct _titleinfo CONTINUEINFO = {
8,
"CONTINUE",
8,
"continue",
4,
"none",
4,
"0m21",
tf3ti00,4,0,0,
0x49,0x3f,mapbossunknown
};

const struct _titleinfo ENDINGINFO = {
21,
"A WAR WITHOUT THE END",
9,
"all clear",
4,
"none",
4,
"1m04",
tf3ti01,1,0,0,
0x49,0x3f,mapbossunknown
};

const struct _titleinfo STAFFINFO = {
7,
"PRESENT",
9,
"all clear",
10,
"cool staff",
4,
"3m07",
tf3ti11,0,0,0,
0x49,0x3f,mapbossunknown
};

const struct _titleinfo GAMEOVERINFO = {
9,
"GAME OVER",
7,
"no more",
4,
"none",
4,
"0m04",
tf3ti00,3,0,0,
0x49,0x3f,mapbossunknown
};

const struct _titleinfo SQUADINFO = {
11,
"METAL SQUAD",
9,
"tfiv wall",
9,
"evil core",
4,
"4m40",
tf3ti12,0,tf3ti13,0,
0x25,0x6b,mapbossunknown
};

const struct _titleinfo TF4STAFFINFO = {
23,
"STAND UP AGAINST MYSELF",
10,
"tfiv staff",
10,
"cool staff",
4,
"1m49",
tf3ti14,0,0,0,
0x25,0x6b,mapbossunknown
};

const struct _titleinfo * const SONGINFO[] = {
    (const struct _titleinfo*)0,
    &TITLEINFO,&SELECTINFO,&HYDRAINFO,&HBOSSINFO,
    &GORGONINFO,&GBOSSINFO,&SEIRENINFO,&SBOSSINFO,
    &HAIDESINFO,&HABOSSINFO,&ELLISINFO,&EBOSSINFO,
    &CERBERUSINFO,&BASEINFO,&BASEBOSSINFO,&COREINFO,
    &ORNBOSSINFO,&STAGECLEARINFO,&CONTINUEINFO,&ENDINGINFO,
    &STAFFINFO,&GAMEOVERINFO,&SQUADINFO,&TF4STAFFINFO,
    (const struct _titleinfo*)0
};

// ******
// get big endian numbers
#define GETBIG(x) \
((((unsigned int)(*(unsigned char*)(x)))<<8) | (*(unsigned char*)((x)+1)))

// ****************
// Keyboard
// No input, return on R1 LSB (FF = no key)
// this version HAS got debounce (1 extra frame, so 1/30th second)
// this version ignores the ALT key (the default version returns it as ascii 1)
// this is so arrow keys (fctn/e/s/d/x) just show as letters, for Classic99 )
// just mapping coleco to that, sorta
unsigned char KSCAN() {
    unsigned char ret;
    kscanfast(1);
    if (KSCAN_KEY != 0xff) {
        ret = KSCAN_KEY;
    } else {
        joystfast(1);
        if (KSCAN_JOYY == JOY_UP) ret = 'E';
        else if (KSCAN_JOYY == JOY_DOWN) ret = 'X';
        else if (KSCAN_JOYX == JOY_LEFT) ret = 'S';
        else if (KSCAN_JOYX == JOY_RIGHT) ret = 'D';
        else {
            ret = 0xff;
            DEBOUNCEKEY = ret;
            return ret;
        }
    }

    if (ret == DEBOUNCEKEY) {
        if (!DEBOUNCECNT) {
            return ret;
        }
        --DEBOUNCECNT;
        return 0xff;
    }

    // set up new debounce
    DEBOUNCEKEY = ret;
    DEBOUNCECNT = 1;
    return 0xff;
}

void loadpagevdp(unsigned int vdp, unsigned int page) {
// r3 - bitmap VDP offset for color and pattern
// r4 - page to read data (data comes from page header)
    unsigned char const *pRom;
    unsigned int cnt;
    
    SWITCH_IN_BANK(page);
    
    // read big endian pattern table address from fixed table
    pRom = (unsigned char*)(GETBIG(0xc004)+0x6000);
    // num bytes
    cnt = GETBIG(0xc000);
    vdpmemcpy(vdp, pRom, cnt);
    
    // same for color
    pRom = (unsigned char*)(GETBIG(0xc002)+0x6000);
    // num bytes
    cnt = GETBIG(0xc000);
    vdpmemcpy(vdp+0x2000, pRom, cnt);
}
    
// draw the ship at any X overlaid on the background into a CPU buffer
// R0 - target CPU address
// R1 - source CPU address for background row (must be paged already)
// R2 - number of rows to copy
// R3 - X offset of the ship (assumed to start at 0x7005 and be 22 chars wide) (can be negative or positive, clipping needed)
// uses R4,R5,R6
// All kinds of assumptions about the data layout made here
void shipdraw(unsigned char *pTarg, const unsigned char *pSrc, unsigned char rows, signed char xoff, unsigned int ShipBank) {
// first, fast copy of background data, so we can get away with fewer compares
    memcpy(pTarg, pSrc, rows*(int)32);
	
// now, we have to do a byte by byte copy of the ship, checking for zero
// the ship data IS 32 bytes wide, but we only need to check 22, so we'll fake the
// loop that way. We just adjust bytes to rows
    pTarg += xoff;  // target
    pSrc += ((int)32*8)+5;   //we should start exactly one section down, plus 5 for the start of ship data

    while (rows--) {
        unsigned char idx;
        for (idx=0; idx<22; ++idx) {    // bytes across
            if ((xoff>=0)&&(xoff < 32)) {
                unsigned char n = *(pSrc);    // what is the byte?
                if (n) {    // if non-zero and not offscreen
                    *pTarg = n;
                }
            }
            ++pSrc;         // update source either way
            ++pTarg;        // update target either way
            ++xoff;         // and column for clip checks
        }
        // next row
        pTarg+=10;
        pSrc+=10;
        xoff -= 22;

        // this is slow, so keep the music pace up
        // it needs to be optimized.
        if (vdpLimi&0x80) {
            VDP_INT_POLL;
            SWITCH_IN_BANK(SongBank);
            CALL_PLAYER_SN;
            SWITCH_IN_BANK(ShipBank);
        }
    }
}

// draw the title characters on the screen with row index r5
// r5 - row from 0-9
// Since we never need to REDRAW anything, we can just draw the one row
void drawtit(unsigned char n) {
    unsigned char *pSrc;
    switch (n) {
    case 0:
        SWITCH_IN_BANK(maptitlethird1);
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+32+4;
        vdpmemcpy(0x1800+32+4, pSrc, 4);
	
        SWITCH_IN_BANK(maptitlethird2);
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(2*(int)32)+8;
        vdpmemcpy(0x1800+((int)32*10)+8, pSrc, 1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(2*(int)32)+11;
        vdpmemcpy(0x1800+((int)32*10)+11, pSrc, 1);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(2*(int)32)+16;
        vdpmemcpy(0x1800+((int)32*10)+16, pSrc, 4);

        break;
        
    case 1:
        SWITCH_IN_BANK(maptitlethird1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(2*(int)32)+6;
        vdpmemcpy(0x1800+((int)32*2)+6, pSrc, 2);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(2*(int)32)+13;
        vdpmemcpy(0x1800+((int)32*2)+13, pSrc, 3);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(2*(int)32)+20;
        vdpmemcpy(0x1800+((int)32*2)+20, pSrc, 4);
	
        SWITCH_IN_BANK(maptitlethird2);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(32)+8;
        vdpmemcpy(0x1800+((int)32*9)+8, pSrc, 1);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(32)+11;
        vdpmemcpy(0x1800+((int)32*9)+11, pSrc, 1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(32)+16;
        vdpmemcpy(0x1800+((int)32*9)+16, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(32)+24;
        vdpmemcpy(0x1800+((int)32*9)+24, pSrc, 1);

        break;

    case 2:
        SWITCH_IN_BANK(maptitlethird1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(3*(int)32)+6;
        vdpmemcpy(0x1800+((int)32*3)+6, pSrc, 2);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(3*(int)32)+12;
        vdpmemcpy(0x1800+((int)32*3)+12, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(3*(int)32)+20;
        vdpmemcpy(0x1800+((int)32*3)+20, pSrc, 4);

        SWITCH_IN_BANK(maptitlethird2);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+8;
        vdpmemcpy(0x1800+((int)32*8)+8, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+16;
        vdpmemcpy(0x1800+((int)32*8)+16, pSrc, 3);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+24;
        vdpmemcpy(0x1800+((int)32*8)+24, pSrc, 1);

        break;

    case 3:
        SWITCH_IN_BANK(maptitlethird1);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(4*(int)32)+6;
        vdpmemcpy(0x1800+((int)32*4)+6, pSrc, 2);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+(4*(int)32)+12;
        vdpmemcpy(0x1800+((int)32*4)+12, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*4)+20;
        vdpmemcpy(0x1800+((int)32*4)+20, pSrc, 4);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*7)+8;
        vdpmemcpy(0x1800+((int)32*7)+8, pSrc, 4);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*7)+16;
        vdpmemcpy(0x1800+((int)32*7)+16, pSrc, 4);
		
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*7)+24;
        vdpmemcpy(0x1800+((int)32*7)+24, pSrc, 1);

        break;

    case 4:
        SWITCH_IN_BANK(maptitlethird1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*5)+6;
        vdpmemcpy(0x1800+((int)32*5)+6, pSrc, 2);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*5)+12;
        vdpmemcpy(0x1800+((int)32*5)+12, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*5)+20;
        vdpmemcpy(0x1800+((int)32*5)+20, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*6)+8;
        vdpmemcpy(0x1800+((int)32*6)+8, pSrc, 4);

        break;

    case 5:
        SWITCH_IN_BANK(maptitlethird1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*6)+6;
        vdpmemcpy(0x1800+((int)32*6)+6, pSrc, 2);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*6)+12;
        vdpmemcpy(0x1800+((int)32*6)+12, pSrc, 1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*5)+8;
        vdpmemcpy(0x1800+((int)32*5)+8, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*5)+16;
        vdpmemcpy(0x1800+((int)32*5)+16, pSrc, 4);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*5)+25;
        vdpmemcpy(0x1800+((int)32*5)+25, pSrc, 1);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*5)+27;
        vdpmemcpy(0x1800+((int)32*5)+27, pSrc, 1);
        
        break;

    case 6:
        SWITCH_IN_BANK(maptitlethird1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*7)+7;
        vdpmemcpy(0x1800+((int)32*7)+7, pSrc, 1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*7)+12;
        vdpmemcpy(0x1800+((int)32*7)+12, pSrc, 4);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*7)+20;
        vdpmemcpy(0x1800+((int)32*7)+20, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*4)+8;
        vdpmemcpy(0x1800+((int)32*4)+8, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*4)+16;
        vdpmemcpy(0x1800+((int)32*4)+16, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*4)+24;
        vdpmemcpy(0x1800+((int)32*4)+24, pSrc, 4);
	
        break;
        
    case 7:
        SWITCH_IN_BANK(maptitlethird2);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*0)+7;
        vdpmemcpy(0x1800+((int)32*8)+7, pSrc, 1);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*0)+13;
        vdpmemcpy(0x1800+((int)32*8)+13, pSrc, 3);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*0)+21;
        vdpmemcpy(0x1800+((int)32*8)+21, pSrc, 3);

        SWITCH_IN_BANK(maptitlethird1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*3)+8;
        vdpmemcpy(0x1800+((int)32*3)+8, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*3)+16;
        vdpmemcpy(0x1800+((int)32*3)+16, pSrc, 3);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*3)+24;
        vdpmemcpy(0x1800+((int)32*3)+24, pSrc, 4);
	
        break;

    case 8:
        SWITCH_IN_BANK(maptitlethird2);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*1)+7;
        vdpmemcpy(0x1800+((int)32*9)+7, pSrc, 1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*1)+12;
        vdpmemcpy(0x1800+((int)32*9)+12, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*1)+20;
        vdpmemcpy(0x1800+((int)32*9)+20, pSrc, 4);
	
        SWITCH_IN_BANK(maptitlethird1);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*2)+8;
        vdpmemcpy(0x1800+((int)32*2)+8, pSrc, 4);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*2)+16;
        vdpmemcpy(0x1800+((int)32*2)+16, pSrc, 4);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*2)+24;
        vdpmemcpy(0x1800+((int)32*2)+24, pSrc, 4);
	
        break;

    case 9:
        SWITCH_IN_BANK(maptitlethird2);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*2)+7;
        vdpmemcpy(0x1800+((int)32*10)+7, pSrc, 1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*2)+12;
        vdpmemcpy(0x1800+((int)32*10)+12, pSrc, 4);

        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*2)+20;
        vdpmemcpy(0x1800+((int)32*10)+20, pSrc, 4);

        SWITCH_IN_BANK(maptitlethird1);
	
        pSrc = (unsigned char*)(GETBIG(0xc008)+0x6000);
        pSrc += ((int)32*16)+((int)32*1)+8;
        vdpmemcpy(0x1800+((int)32*1)+8, pSrc, 2);

        break;
    }
}
	
// translation to convert ascii to the silly places I put text...
// 0 is at 26, A (blue) is at 43, a (yellow) is at 77
// delta is -22 for numbers and uppercase, -20 for lowercase
// we take no responsibility for non-alphanumerics.
// R0 - VDP address
// R1 - CPU address
// R2 - bytes to copy
void showtext(unsigned int vdp, const unsigned char *pTxt, unsigned char cnt) {
    VDP_SET_ADDRESS_WRITE(vdp);
    
    while (cnt--) {
        unsigned char x;
        
        x=*(pTxt++);
        if (x == ' ') {
            x = 0;
        } else {
            x -= 22;
            if (x >= 0x4b) {    // lowercase A after subtraction
                x+=2;           // give the 2 back
            }
        }
        VDPWD = x;
    }
}
	
// place crosshair sprites
// R6 - row (screen coordinates)
// r7 - column (screen coordinates)
// r13 - row offset for top
// r14 - column offset for left
void drawcrosshairs(unsigned char row, unsigned char col, unsigned char roff, unsigned char coff) {
    unsigned char tmp;
    
    VDP_SET_ADDRESS_WRITE(0x1b00);  // sprite table

    tmp = roff;

    VDPWD=tmp;
    VDP_SAFE_DELAY();
    VDPWD=col;
    VDP_SAFE_DELAY();
    VDPWD=0x74;             // vertical beam (4 of these)
    VDP_SAFE_DELAY();
    VDPWD=0x08;             // dark red
    tmp+=0x20;
    VDP_SAFE_DELAY();
    VDPWD=tmp;
    VDP_SAFE_DELAY();
    VDPWD=col;
    VDP_SAFE_DELAY();
    VDPWD=0x74;             // vertical beam (4 of these)
    VDP_SAFE_DELAY();
    VDPWD=0x08;             // dark red
    tmp+=0x20;
    VDP_SAFE_DELAY();
    VDPWD=tmp;
    VDP_SAFE_DELAY();
    VDPWD=col;
    VDP_SAFE_DELAY();
    VDPWD=0x74;             // vertical beam (4 of these)
    VDP_SAFE_DELAY();
    VDPWD=0x08;             // dark red
    tmp+=0x20;
    VDP_SAFE_DELAY();
    VDPWD=tmp;
    VDP_SAFE_DELAY();
    VDPWD=col;
    VDP_SAFE_DELAY();
    VDPWD=0x74;             // vertical beam (4 of these)
    VDP_SAFE_DELAY();
    VDPWD=0x08;             // dark red
    VDP_SAFE_DELAY();

    tmp = coff;
    
    VDPWD=row;
    VDP_SAFE_DELAY();
    VDPWD=tmp;
    VDP_SAFE_DELAY();
    VDPWD=0x78;             // horizontal beam (3 of these)
    VDP_SAFE_DELAY();
    VDPWD=0x08;             // dark red
    VDP_SAFE_DELAY();
    tmp += 0x20;
    VDPWD=row;
    VDP_SAFE_DELAY();
    VDPWD=tmp;
    VDP_SAFE_DELAY();
    VDPWD=0x78;             // horizontal beam (3 of these)
    VDP_SAFE_DELAY();
    VDPWD=0x08;             // dark red
    VDP_SAFE_DELAY();
    tmp += 0x20;
    VDPWD=row;
    VDP_SAFE_DELAY();
    VDPWD=tmp;
    VDP_SAFE_DELAY();
    VDPWD=0x78;             // horizontal beam (3 of these)
    VDP_SAFE_DELAY();
    VDPWD=0x08;             // dark red
    VDP_SAFE_DELAY();
}
	
// ************
// new music on briefing screen
// r5 - index (x2) into music table
void newmusic(unsigned char index) {
// load new crosshair target
    const struct _titleinfo *pSong;
    unsigned int cnt2;
    const unsigned char *pos;
    unsigned char cnt, cnt3;
    
    pSong = SONGINFO[index];        // song index, table for this song
    crosshairtar = ((unsigned int)pSong->row)*256;      // crosshair row
    crosshairtac = ((unsigned int)pSong->col)*256;      // crosshair column

// calculate new crosshair movement speeds - we want to get there in 3 seconds or so
// we can just divide, with fixed point we should get there... hopefully )
    crosshairspr = (crosshairtar-crosshairrow)/180;
    crosshairspc = (crosshairtac-crosshaircol)/180;

// clear text box
    cnt2 = 0x1800+(5*(int)32)+17;
    for (cnt=0; cnt<8; ++cnt) {
        vdpmemset(cnt2, 0, 14);
        cnt2+=32;
    }
	
// load pointers to text information
    statusline = 0;                 // reset back to song name
    statuscnt = 255;                // about 4 seconds (max unsigned char)
    textline = 0;                   // first line of text
    textptr = txtstage;             // address of next character
    textcount = *(textptr++);       // count of characters
    textdelay = 1;                  // 1 frame to appear
    textvdp = 0x1800+(6*(int)32)+17;  // VDP address

// load new portrait - this one is a bit tricky as we have one row in group 2, and the rest in group 3
// fortunately, the top row always counts up sequentially from 1 (we are relying on that), so we can
// just copy the first 16 characters blindly in at char 240, and remap that first row
// we're going to redraw the whole thing, so no need to clear it first

    SWITCH_IN_BANK(pSong->pic);

// just copy 16 characters blindly to character 240
    pos = (unsigned char*)(GETBIG(0xc004)+0x6000);
    vdpmemcpy(0xf80, pos, 128);    // pattern

    pos = (unsigned char*)(GETBIG(0xc002)+0x6000);
    vdpmemcpy(0x2f80, pos, 128);    // color

// now load the 16 characters to the grid - adding 240 as we go and ignoring 0 (becomes >09)
    VDP_SET_ADDRESS_WRITE(0x1800+(15*(int)32)+17);
    // get address of map data
    pos = (unsigned char*)(GETBIG(0xc008)+0x6000);

    for (cnt=0; cnt<14; ++cnt) {    // 14 columns
        unsigned char x;
        
        x=*(pos++);             // get byte
        if (x) {
            x+=0xf0;            // add 240
        } else {
            x=9;                // background char
        }
      
        VDPWD = x;              // write to VDP
    }

// then we can load the whole bit for group 3 at character 77 (this kills yellow text, which we don't use)
// pretty much the same loop here, but we add 77 and it's 6 rows long

    // pattern
    pos = (unsigned char *)(GETBIG(0xc004)+0x6000);
    cnt2 = GETBIG(0xc000);
    vdpmemcpy(0x1268, pos, cnt2);
    
    // Color
    pos = (unsigned char *)(GETBIG(0xc002)+0x6000);
    cnt2 = GETBIG(0xc000);
    vdpmemcpy(0x3268, pos, cnt2);

// now load the characters to the grid - adding 77 as we go and ignoring 0 (becomes >09)
    cnt2 = 0x1800+(16*(int)32)+17;   // address of map data
    pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
    pos += 14;                  // skip the first row
    for (cnt = 0; cnt<6; ++cnt) {
        VDP_SET_ADDRESS_WRITE(cnt2);
        for (cnt3=0; cnt3<14; ++cnt3) { // 14 columns
            unsigned char x;
            x = *(pos++);       // get byte
            if (x == 0) {
                x = 9;      // background char
            } else {
                x += 0x4d;  // add 77
            }
            VDPWD = x;
        }
        cnt2+= 32;  // next row
    }

// load new song and start playing
    SongBank = pSong->s1;
    nextsong = pSong->s2;
    nextsongidx = pSong->idx2;
    
    SWITCH_IN_BANK(pSong->s1);
    
    StartSong((unsigned char*)0xc000, pSong->idx1);
}

// ******************** MAIN CODE HERE **********************

void START() {
    const unsigned char *pos, *pos2;
    unsigned char xcnt;
    signed char xpos;
    unsigned int vdp;
    
// turn VDP back off again (assumes that loader already set up bitmap)
// turn on with 0x81E3
    VDP_SET_ADDRESS(0x81a3);

// init the music player by calling StopSong
    SongBank=0;
    StopSong();

// clear the screen again
    vdpmemset(0x1800, 0, 768);
	
// first, we need to load up the title page. There are three banks involved
    loadpagevdp(0, maptitlethird1);
    pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
    vdpmemcpy(0x1800, pos, 256);   // 1/3rd of background screen

    loadpagevdp(0x800, maptitlethird2);
    pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
    vdpmemcpy(0x1900, pos, 256);   // 1/3rd of background screen

    loadpagevdp(0x1000, maptitlethird3);
    pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
    vdpmemcpy(0x1a00, pos, 256);   // 1/3rd of background screen
    		
// initialize the title music
    SongBank = (const unsigned char*)tf3ti00;
    SWITCH_IN_BANK(tf3ti00);
    StartSong((unsigned char*)0xc000, 0);
	
// that's good, now we can turn on the screen and start the music
    VDP_SET_ADDRESS(0x81e3);
	
// first, a brief pause before the ship appears
    delay(60);
	
// now we are going to flicker the ship in from left to right until it is centered
// the ship starts at row 12 and is 11 rows high
// rows 12-15 are in group 2, and 16-22 are in group 3 (different banks)
// it is 22 characters wide with 5 cells of gap on each side
// we also have to not draw 0-filled cells and clip at the edges
//
// We'll double buffer it to reduce the odds of unintended flicker, hopefully the
// work and blit will be quick enough - SCRNBUF is 11*(int)32 bytes
//
#define shspeed 1
    xpos=-21;                   // x coordinate (for left side)
    xcnt=shspeed;               // frames to count
	
// draw the ship flickering at x=r13, then x=10-r13
    for (;;) {
    // first the left version, group 2 (last 4 rows)
        SWITCH_IN_BANK(maptitlethird2); //		* bank it in
        
        // map data for group 2 (first group is bg, last group is ship)
        pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
        pos += (int)32*4;        // skip to row 4 (which is really row 12, cause group 2)
        shipdraw(SCRNBUF, pos, 4, xpos, maptitlethird2);
        vdpmemcpy(0x1900+(4*(int)32), SCRNBUF, (int)32*4);   // 4 rows from SCRNBUF to second third VDP

    // then group 3, 7 rows
        SWITCH_IN_BANK(maptitlethird3); //		* bank it in
        
        // map data for group 2 (first group is bg, last group is ship)
        pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
        shipdraw(SCRNBUF, pos, 7, xpos, maptitlethird3);
        vdpmemcpy(0x1a00, SCRNBUF, (int)32*7);  // copy 7 rows
        
        delay(0);

        if (xpos == 5) break;       // silly to do this every time, but easy to get the last frame drawn )
	
        // now we need to do the same thing, but on the RIGHT side. We can skip the check for r13 though
        // group 2 (last 4 rows)
        
        SWITCH_IN_BANK(maptitlethird2); //		* bank it in
        
        // map data for group 2 (first group is bg, last group is ship)
        pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
        pos += (int)32*4;        // skip to row 4 (which is really row 12, cause group 2)
        shipdraw(SCRNBUF, pos, 4, 10-xpos, maptitlethird2);
        vdpmemcpy(0x1900+4*(int)32, SCRNBUF, (int)32*4);     // 4 rows

    // then group 3, 7 rows
        
        SWITCH_IN_BANK(maptitlethird3); //		* bank it in
        
        pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
        shipdraw(SCRNBUF, pos, 7, 10-xpos, maptitlethird3);
        vdpmemcpy(0x1a00, SCRNBUF, (int)32*7);          // 7 rows

        delay(0);
        
        // count down and move if needed
        if (--xcnt == 0) {
            xcnt = shspeed;     // reload it
            ++xpos;             // next step
        }
    }

    // there's about a half second delay here...
    delay(40);

// now it's time for the title text. I'm thinking too hard about how to do it "right"
// so I'm going to do it completely manually. Takes more code, but we should have room to spare.
    for (unsigned char cnt=0; cnt<10; ++cnt) {
        drawtit(cnt);       // draw the relevant bits
        delay(5);
    }

// all that's left now is the III blocking in. This lives from rows 11-14, columns 13-18
    pos = TITIII;       // random number table
	
	for (;;) {
        unsigned char x;
        
        SWITCH_IN_BANK(maptitlethird2); //		* bank in the second third
        
        x = *(pos++);   // get random offset (+1)
        if (!x) break;  // if we're done, exit
        
        pos2 = (unsigned char *)(GETBIG(0xc008)+0x6000); // MD0 for ROM offset

        VDP_SET_ADDRESS_WRITE(0x196c+x);
        VDPWD = *(pos2+0x26c+x);    // write byte to VDP

        delay(2);
    }

// now, we just wait for the music to end!
    while (isSNPlaying) {   // song playing check
        delay(0);
    }
    
// good, now we pause for a second...
    delay(60);
	
// clear the screen, and wait for another half second
    vdpmemset(0x1800, 0, 768);
    delay(30);
	
// next screen! Time for the stage select!
// load the character set (all three pages this one, at least to start)
    loadpagevdp(0, mapbriefing);
    loadpagevdp(0x800, mapbriefing);
    loadpagevdp(0x1000, mapbriefing);
	
// and load the sprite graphics - no nicely defined pointer this time
    pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
    pos -= 16*8+10;     //  distance back to start of sprite data
    vdpmemcpy(0x1b80, pos, 16*8);
	
// and block out the sprite table
    vdpmemset(0x1b00, 0xd0, 128);

// but, we aren't loading the briefing PAGE, just the world map
// which means we need to do it manually. The world map is at
// row 5, column 1, and is 14 cells wide and 17 cells tall

// display STAGE SELECT text in top row 
// but... nooooo, I couldn't put the alphabet at the ASCII location...
    showtext(0x1800+10, STAGESEL, 12);
	
// no paging issues on this one, just bring it in, one row at a time
    pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
    pos += 5*(int)32+1;      // location in the source map
    vdp = 0x1800+(int)32*3+9;    // dest adr
    for (unsigned char cnt=0; cnt<17; ++cnt) {    // number of rows
        vdpmemcpy(vdp, pos, 14);
        vdp+=32;
        pos+=32;
    }
	
// okay, static text is up, initialize our world and the music
    world = 0;      // world (0-4 on stage select screen, then 1-24 on main)
    srow = 27;      // row offset for sprite (to make the edges line up, NOT the center!)
    scol = 80;      // col offset for sprite (to make the edges line up, NOT the center!)
    
    SWITCH_IN_BANK(tf3ti01);
    SongBank = (unsigned char*)tf3ti01;
    StartSong((unsigned char*)0xC000, 0);
	
// now wait for the music to end. as a bonus, the human can select
// a stage with the arrow keys and space, which will change where we start
// the briefing screen

    for (;;) {
        const struct _stagetxt *pStageTxt;
        unsigned char k;
        
        // first, draw the crosshairs and world text
        // we don't have to do much, so we can do this every frame
        delay(0);
        
        // if music over, break
        if (!isSNPlaying) {
            break;
        }
        
        pStageTxt = STAGETXT[world];    // get the pointer
        drawcrosshairs(pStageTxt->row, pStageTxt->col, srow, scol);
        showtext(0x1800+(23*(int)32)+13, pStageTxt->pTxt, 6);    // for writing the world name
        
        k=KSCAN();          // look for new keypress
        if (k == OLDKEY) continue;
        
        OLDKEY = k;         // save it

        // we're looking for S, D and Enter
        if (k == 'D') {
            ++world;
            if (world > 4) world = 0;
            continue;
        }
        
        if (k == 'S') {
            --world;
            if (world > 4) world = 4;
            continue;
        }

        if (k == JOY_FIRE) {
            StopSong();
            MUTE_SOUND();
            break;
        }
    }

// Finally, we get to the meat of the player - the mission briefing screen
// there's a fair bit going on here

    delay(0);   // align with end of frame

// clear the sprites (temporarily)
    vdpmemset(0x1b00, 0xd0, 128);
	
// and clear the screen...
    vdpmemset(0x1800, 0, 768);
	
// graphics and sprites are already loaded, so we just need to bring up the mission screen
// as nice as it'd be to stay in registers, for simplicity we're going to track all this stuff as data
    
    SWITCH_IN_BANK(mapbriefing);    //		* page it in (probably already is)
	
    pos = (unsigned char *)(GETBIG(0xc008)+0x6000);
	vdpmemcpy(0x1800, pos, 768);   // for once, we want the whole thing!
	// special for Coleco, overwrite the top score for Z80
	// 90 is ascii (decimal) for 'Z'
	showtext(0x1829, "9080", 4);

    crosshairrow=0x1000;
    crosshaircol=0x1000;    // current row and col for crosshairs - they move now (0,0 isn't legal)

    weapon = 0;             // zero or 1 only
	
	textline=0;
	textptr=0;
	textcount=0;
	textdelay=0;            // data for displaying text in box
	
	statusline=0;           // index for the status line (changed by AID)
	statuscnt=255;          // about 4 seconds countdown
	
// load up the sprites for the weapon select and targeting (I might delete targeting)
    VDP_SET_ADDRESS_WRITE(0x1b1c);
    VDPWD = 0x07;
    VDP_SAFE_DELAY();
    VDPWD = 0x78;
    VDP_SAFE_DELAY();
    VDPWD = 0x70;
    VDP_SAFE_DELAY();
    VDPWD = 0x0f;
    VDP_SAFE_DELAY();
	
	VDPWD = 0x84;
	VDP_SAFE_DELAY();
	VDPWD = 0xb0;
	VDP_SAFE_DELAY();
    VDPWD = 0x7c;
    VDP_SAFE_DELAY();
    VDPWD = 0x07;
    VDP_SAFE_DELAY();

    world <<= 1;            // multiply by 2 to account for bosses
    world += 3;             // then add 3 to the selected music, to skip null, title and stage select
    newmusic(world);

// and finally, here's the main loop	
    for (;;) {
        delay(0);           // handle music and quit
        
        // move crosshairs and draw them
        crosshairrow += crosshairspr;
        crosshaircol += crosshairspc;
        if ((crosshairrow&0xff00) == (crosshairtar&0xff00)) crosshairspr=0;
        if ((crosshaircol&0xff00) == (crosshairtac&0xff00)) crosshairspc=0;
        drawcrosshairs(crosshairrow>>8, crosshaircol>>8, 43, 16);
        
        // clear status line (can we afford to redraw status line every frame?)
        vdpmemset(0x1800+23*(int)32, 0, 32);
	
        // countdown status line
        if (--statuscnt == 0) {
            statuscnt = 255;
            statusline++;
            if (0 == STATUSTEXT[statusline]) statusline = 0;
        }
            
        // draw status line
        if (STATUSTEXT[statusline] == 0) {
            // display the song title
            unsigned char cnt;
            
            cnt = SONGINFO[world]->l1;
            showtext(0x1800+23*(int)32+((32-cnt)>>1), SONGINFO[world]->t01, cnt);
        } else {
            // display the information row
            unsigned char cnt;
            cnt = *STATUSTEXT[statusline];
            showtext(0x1800+23*(int)32+((32-cnt)>>1), (STATUSTEXT[statusline])+1, cnt);
        }

        // draw next text character
        --textdelay;
        if (0 == textdelay) {       // count down text delay (this may wrap around at the end, that's okay)
            if (textptr != 0) {     // get the byte pointer, if any
                showtext(textvdp, textptr, 1);
                VDP_SAFE_DELAY();
                VDPWD = 0x0a;       // draw the cursor
                
                ++textptr;
                ++textvdp;
                textdelay = 3;
                --textcount;
                if (0 == textcount) {
                    // we finished a row of text, so work out the next one
                    // clear the cursor first
                    vdpchar(textvdp, 0);

                    ++textline;
                    switch (textline) {
                    default:
                        // no more text - clear the pointer
                        textptr = 0;
                        break;
                        
                    case 0:
                        textvdp = 0x5800+(6*(int)32)+17;
                        textcount = *txtstage;
                        textptr = txtstage+1;
                        break;
                        
                    case 1:
                        textvdp = 0x5800+(7*(int)32)+19;
                        textcount = SONGINFO[world]->l2;
                        textptr = SONGINFO[world]->t02;
                        break;
                        
                    case 2:
                        textvdp = 0x5800+(8*(int)32)+17;
                        textcount = *txttarget;
                        textptr = txttarget+1;
                        break;

                    case 3:
                        textvdp = 0x5800+(9*(int)32)+19;
                        textcount = SONGINFO[world]->l3;
                        textptr = SONGINFO[world]->t03;
                        break;
	
                    case 4:
                        textvdp = 0x5800+(10*(int)32)+17;
                        textcount = *txtduration;
                        textptr = txtduration+1;
                        break;

                    case 5:
                        textvdp = 0x5800+(11*(int)32)+19;
                        textcount = SONGINFO[world]->l4;
                        textptr = SONGINFO[world]->t04;
                        break;
                    }
                }
            }
        }
        
        // check for end of music (make sure we ALSO check that text is done drawing)
        
        // if song is over, then continue to next check
        if (!isSNPlaying) {
            // check if there's a next song to play
            if (nextsong != 0) {
                // there IS a next song
                SWITCH_IN_BANK(nextsong);
                SongBank = nextsong;
                StartSong((unsigned char*)0xC000, nextsongidx);
                nextsong = 0;   // make sure we don't play it again
            } else if (textptr == 0) {  // music is over, but is the text?
                // all done, hit the next tune
                world++;
                if (SONGINFO[world] == 0) world = 1;    // wrap around
                newmusic(world);
            }
        }

        // check keys
        // we support S, D, 1,2,3,4,7, 0
        k = KSCAN();
        if (k == OLDKEY) continue;
        
        OLDKEY = k;
        
        if (k == 'S') {
            // previous song
            --world;
            if (SONGINFO[world]==0) world = 24;
            StopSong();
            MUTE_SOUND();
            newmusic(world);
            continue;
        }
        
        if (k == 'D') {
            // next song
            ++world;
            if (SONGINFO[world]==0) world = 1;
            StopSong();
            MUTE_SOUND();
            newmusic(world);
            continue;
        }
        
        if (k == '1') {
            // lift 1
            VDP_SET_ADDRESS_WRITE(0x1800+2*(int)32+27);
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0;
            VDP_SAFE_DELAY();
            VDPWD = 0;
            VDP_SAFE_DELAY();
            VDPWD = 0;
            VDP_SAFE_DELAY();
            continue;
         };

        if (k == '2') {
            // lift 2
            VDP_SET_ADDRESS_WRITE(0x1800+2*(int)32+27);
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0;
            VDP_SAFE_DELAY();
            VDPWD = 0;
            VDP_SAFE_DELAY();
            continue;
         };

        if (k == '3') {
            // lift 3
            VDP_SET_ADDRESS_WRITE(0x1800+2*(int)32+27);
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0;
            VDP_SAFE_DELAY();
            continue;
         };
         
        if (k == '4') {
            // lift 4
            VDP_SET_ADDRESS_WRITE(0x1800+2*(int)32+27);
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            VDPWD = 0x28;
            VDP_SAFE_DELAY();
            continue;
         };

        if (k == '0') {
            // change weapon
            weapon++;
            
            VDP_SET_ADDRESS_WRITE(0x1b1d);

            if (weapon != 1) {
                weapon = 0;
                VDPWD = 0x78;
            } else {
                VDPWD = 0x88;
            }
            
            continue;
        }
        
        if (k == '7') {
            ++statusline;
            if (STATUSTEXT[statusline] == 0) {
                statusline = 0;
            }
            statuscnt = 255;
        }
    }
}
