* Thunder Force III Tribute music player
* 
* I first saw Thunder Force III back in 1987 or 1988, and have been hooked on it since.
* It's the reason I got a Sega Genesis, and I've always wanted my TI to do anything
* even remotely close. A major part of my vgmcomp2 music converter was wanting to
* be able to convert Genesis music, specifically for this sound track. So now, though
* I don't intend to do the whole game, I've used my conversion toolchains to do
* this little musical and graphical tribute.
* 
* There's a little over 64k of compressed music, and more than that in graphics, so
* there's a lot of bank switching. Each song fits in a single bank guaranteed, so
* that helps a lot. 
*
* I'm torn on making it run without needing the 32k memory expansion or not, since the
* actual RAM usage would work in the scratchpad, but I worry about the CPU usage of the
* player when every byte accessed actually takes a write and a read. All the paging would
* be painful and I've already spent too long on this.
*
* Soooo... this program is going to be executing from 32K RAM and a separate loader cart
* will exist.

* bank definitions
loader equ >6000
ea5pt1 equ >6002
ea5pt2 equ >6004
ea5pt3 equ >6006
tf3ti00 equ >6008
tf3ti01 equ >600a
tf3ti02 equ >600c
tf3ti03 equ >600e
tf3ti04 equ >6010
tf3ti05 equ >6012
tf3ti06 equ >6014
tf3ti07 equ >6016
tf3ti08 equ >6018
tf3ti09 equ >601a
tf3ti10 equ >601c
tf3ti11 equ >601e
tf3ti12 equ >6038
tf3ti13 equ >603a
tf3ti14 equ >603c
mapbossunknown equ >6020
mapbosscerberus equ >6022
mapbossfish equ >6024
mapbossfort equ >6026
mapbossgargoyle equ >6028
mapbosslobster equ >602a
mapbossvulcan equ >602c
mapbriefing equ >602e
mapbriefingornbase equ >6030
maptitlethird1 equ >6032
maptitlethird2 equ >6034
maptitlethird3 equ >6036

** WARNING: Do not use R8 and R9 - they containthe VDP write addresses, and R15 has the song bank

* memory allocation only, don't put initialized data here! It won't get loaded anyway!
* low ram for data buffers
	AORG >2000
	
* Music player	
strDat
	bss 72
songVol
	bss 4
songNote
	bss 8
workBuf
	bss 2
retSave
    bss 2
    
* tf3 stuff
SCRNBUF	BSS 11*32		* buffer used for mixing characters on the title page
OLDKEY bss 2			* remember last key pressed

* briefing screen
crosshairrow bss 2		* current row of the crosshair in 8.8 fixed point
crosshaircol bss 2		* current column of the crosshair in 8.8 fixed point
crosshairspr bss 2		* row speed of the crosshair in 8.8
crosshairspc bss 2		* column speed of the crosshair in 8.8
weapon bss 2			* current weapon (0 or 1)
textline bss 2			* current line being printed in display
textptr bss 2			* pointer to current output char
textcount bss 2			* number of characters left to print
textdelay bss 2			* delay frames left before next character
statusline bss 2		* index of status line for AID (0 = song title)
nextsong bss 2			* page of next song for tunes with two parts, 0 if none
nextsongidx bss 2		* index for the next song

* high RAM for program
	AORG >A000
	DEF START
	
	B @START

	COPY "tiSNonly.asm"

* data
BIT01  DATA >0001
QUITK  DATA >1100				* CRU value for QUIT
CHK32  DATA >FFE0				* inverse of >1f for clip checks

*****************

* random data for displaying III
* generated in BLASSIC, 26 entries of y*32+x+1
TITIII
	DATA 70,66,99,101,2,34,98,5,102,3,37,35,65,97,36,69,38,68,4,1,100,6,33,67
	DATA 0

*****************
* stage names are preceded by sprite coordinates (row,col) assuming just the world grid
* then always 6 characters of text
* For the sprite crosshairs, left is always the exact pixel, but specify right as
* desired minus 31, it's at the bottom of the mag 4 sprite
STAGESEL
	TEXT 'STAGE SELECT'
STAGETXT
	data txthydra,txtgorgon,txtseiren,txthaides,txtellis
txthydra
	data (-3)*8+3,2*8-2
	text 'HYDRA '
txtgorgon
	data 3*8+6,11*8-2
	text 'GORGON'
txtseiren
	data 9*8+7,11*8-2
	text 'SEIREN'
txthaides
	data 9*8+7,3*8-1
	text 'HAIDES'
txtellis
	data 4*8+10,0*8+3
	text 'ELLIS '
	even

*****************
* Song information for the status screen
* 0 - status line, 1 - stage, 2 - Target, 3 - Duration, 4 - song 1 AND 2, crosshair row, crosshair col
* Song data is page, then index
SONGINFO
	DATA 0,TITLEINFO,SELECTINFO,HYDRAINFO,HBOSSINFO
	DATA GORGONINFO,GBOSSINFO,SEIRENINFO,SBOSSINFO
	DATA HAIDESINFO,HABOSSINFO,ELLISINFO,EBOSSINFO
	DATA CERBERUSINFO,BASEINFO,BASEBOSSINFO,COREINFO
	DATA ORNBOSSINFO,STAGECLEARINFO,CONTINUEINFO,ENDINGINFO
	DATA STAFFINFO,GAMEOVERINFO,SQUADINFO,TF4STAFFINFO,0
	
TITLEINFO	
	DATA T01,T02,T03,T04,S01,4,8
T01	DATA 26
	TEXT 'THE WIND BLEW ALL DAY LONG'
	EVEN
T02	DATA 5
	TEXT 'TITLE'
	EVEN
T03	DATA 3
	TEXT 'TF3'
	EVEN
T04	DATA 4
	TEXT '0M15'
	EVEN
S01	DATA TF3TI00,0,0,0
	
SELECTINFO
	DATA T11,T12,T13,T14,S11,4,8
T11	DATA 16
	TEXT 'BEYOND THE PEACE'
	EVEN
T12	DATA 12
	TEXT 'STAGE SELECT'
	EVEN
T13	DATA 6
	TEXT 'CHOOSE'
	EVEN
T14	DATA 4
	TEXT '1M01'
	EVEN
S11	DATA TF3TI01,0,0,0

HYDRAINFO
	DATA T21,T22,T23,T24,S21,(-3)*8+3,2*8-2
T21	DATA 16
	TEXT 'BACK TO THE FIRE'
	EVEN
T22	DATA 5
	TEXT 'HYDRA'
	EVEN
T23	DATA 8
	TEXT 'GARGOYLE'
	EVEN
T24	DATA 4
	TEXT '2M15'
	EVEN
S21	DATA TF3TI02,0,0,0

HBOSSINFO
	DATA T31,T32,T33,T34,S31,(-3)*8+3,2*8-2
T31	DATA 8
	TEXT 'GARGOYLE'
	EVEN
T32	DATA 5
	TEXT 'HYDRA'
	EVEN
T33	DATA 8
	TEXT 'GARGOYLE'
	EVEN
T34	DATA 4
	TEXT '1M38'
	EVEN
S31	DATA TF3TI03,0,0,0

GORGONINFO
	DATA T41,T42,T43,T44,S41,3*8+6,11*8-2
T41	DATA 10
	TEXT 'VENUS FIRE'
	EVEN
T42	DATA 6
	TEXT 'GORGON'
	EVEN
T43	DATA 11
	TEXT 'TWIN VULCAN'
	EVEN
T44	DATA 4
	TEXT '2M54'
	EVEN
S41	DATA TF3TI00,5,0,0

GBOSSINFO
	DATA T51,T52,T53,T54,S51,3*8+6,11*8-2
T51	DATA 11
	TEXT 'TWIN VULCAN'
	EVEN
T52	DATA 6
	TEXT 'GORGON'
	EVEN
T53	DATA 11
	TEXT 'TWIN VULCAN'
	EVEN
T54	DATA 4
	TEXT '1M11'
	EVEN
S51	DATA TF3TI03,1,0,0

SEIRENINFO
	DATA T61,T62,T63,T64,S61,9*8+7,11*8-2
T61	DATA 20
	TEXT 'THE GRUBBY DARK BLUE'
	EVEN
T62	DATA 6
	TEXT 'SEIREN'
	EVEN
T63	DATA 11
	TEXT 'KING FISH'
	EVEN
T64	DATA 4
	TEXT '2M32'
	EVEN
S61	DATA TF3TI04,0,0,0

SBOSSINFO
	DATA T71,T72,T73,T74,S71,9*8+7,11*8-2
T71	DATA 11
	TEXT 'KING FISH'
	EVEN
T72	DATA 6
	TEXT 'SEIREN'
	EVEN
T73	DATA 11
	TEXT 'KING FISH'
	EVEN
T74	DATA 4
	TEXT '1M30'
	EVEN
S71	DATA TF3TI05,0,0,0

HAIDESINFO
	DATA T81,T82,T83,T84,S81,9*8+7,3*8-1
T81	DATA 5
	TEXT 'TRUTH'
	EVEN
T82	DATA 6
	TEXT 'HAIDES'
	EVEN
T83	DATA 9
	TEXT 'G LOBSTER'
	EVEN
T84	DATA 4
	TEXT '1M43'
	EVEN
S81	DATA TF3TI06,0,0,0

HABOSSINFO
	DATA T91,T92,T93,T94,S91,9*8+7,3*8-1
T91	DATA 9
	TEXT 'G LOBSTER'
	EVEN
T92	DATA 6
	TEXT 'HAIDES'
	EVEN
T93	DATA 9
	TEXT 'G LOBSTER'
	EVEN
T94	DATA 4
	TEXT '1M39'
	EVEN
S91	DATA TF3TI02,1,0,0

ELLISINFO
	DATA T101,T102,T103,T104,S101,4*8+10,0*8+3
T101	DATA 19
	TEXT 'FINAL TAKE A CHANCE'
	EVEN
T102	DATA 5
	TEXT 'ELLIS'
	EVEN
T103	DATA 11
	TEXT 'MOBILE FORT'
	EVEN
T104	DATA 4
	TEXT '1M41'
	EVEN
S101	DATA TF3TI04,1,0,0

EBOSSINFO
	DATA T111,T112,T113,T114,S111,4*8+10,0*8+3
T111	DATA 11
	TEXT 'MOBILE FORT'
	EVEN
T112	DATA 5
	TEXT 'ELLIS'
	EVEN
T113	DATA 11
	TEXT 'MOBILE FORT'
	EVEN
T114	DATA 4
	TEXT '1M03'
	EVEN
S111	DATA TF3TI01,2,0,0

CERBERUSINFO
	DATA T121,T122,T123,T124,S121,1*8+10,5*8+3
T121	DATA 31
	TEXT 'HIS BEHAVIOUR INSPIRED DISTRUST'
	EVEN
T122	DATA 8
	TEXT 'CERBERUS'
	EVEN
T123	DATA 8
	TEXT 'CERBERUS'
	EVEN
T124	DATA 4
	TEXT '5M16'
	EVEN
S121	DATA TF3TI05,1,TF3TI07,0

BASEINFO
	DATA T131,T132,T133,T134,S131,4*8+10,0*8+3
T131	DATA 26
	TEXT 'HUNGER MADE THEM DESPERATE'
	EVEN
T132	DATA 8
	TEXT 'ORN BASE'
	EVEN
T133	DATA 7
	TEXT 'NO DATA'
	EVEN
T134	DATA 4
	TEXT '3M51'
	EVEN
S131	DATA TF3TI08,0,0,0

BASEBOSSINFO
	DATA T141,T142,T143,T144,S141,4*8+10,0*8+3
T141	DATA 8
	TEXT 'OFF LUCK'
	EVEN
T142	DATA 8
	TEXT 'ORN BASE'
	EVEN
T143	DATA 7
	TEXT 'NO DATA'
	EVEN
T144	DATA 4
	TEXT '1M38'
	EVEN
S141	DATA TF3TI09,0,0,0

COREINFO
	DATA T151,T152,T153,T154,S151,4*8+10,0*8+3
T151	DATA 12
	TEXT 'FINAL MOMENT'
	EVEN
T152	DATA 8
	TEXT 'ORN CORE'
	EVEN
T153	DATA 6
	TEXT 'CHA OS'
	EVEN
T154	DATA 4
	TEXT '1M23'
	EVEN
S151	DATA TF3TI03,2,0,0

ORNBOSSINFO
	DATA T161,T162,T163,T164,S161,4*8+10,0*8+3
T161	DATA 17
	TEXT 'BE MENACED BY ORN'
	EVEN
T162	DATA 6
	TEXT 'CHA OS'
	EVEN
T163	DATA 6
	TEXT 'CHA OS'
	EVEN
T164	DATA 4
	TEXT '1M49'
	EVEN
S161	DATA TF3TI00,1,TF3TI10,0

STAGECLEARINFO
	DATA T171,T172,T173,T174,S171,4*8+10,0*8+3
T171	DATA 11
	TEXT 'STAGE CLEAR'
	EVEN
T172	DATA 5
	TEXT 'CLEAR'
	EVEN
T173	DATA 9
	TEXT 'DESTROYED'
	EVEN
T174	DATA 4
	TEXT '0M02'
	EVEN
S171	DATA TF3TI00,2,0,0

CONTINUEINFO
	DATA T181,T182,T183,T184,S181,4*8+10,0*8+3
T181	DATA 8
	TEXT 'CONTINUE'
	EVEN
T182	DATA 9
	TEXT 'ALL CLEAR'
	EVEN
T183	DATA 4
	TEXT 'NONE'
	EVEN
T184	DATA 4
	TEXT '0M21'
	EVEN
S181	DATA TF3TI00,4,0,0

ENDINGINFO
	DATA T191,T192,T193,T194,S191,4*8+10,0*8+3
T191	DATA 21
	TEXT 'A WAR WITHOUT THE END'
	EVEN
T192	DATA 9
	TEXT 'ALL CLEAR'
	EVEN
T193	DATA 4
	TEXT 'NONE'
	EVEN
T194	DATA 4
	TEXT '1M04'
	EVEN
S191	DATA TF3TI01,1,0,0

STAFFINFO
	DATA T201,T202,T203,T204,S201,4*8+10,0*8+3
T201	DATA 7
	TEXT 'PRESENT'
	EVEN
T202	DATA 9
	TEXT 'ALL CLEAR'
	EVEN
T203	DATA 13
	TEXT 'AWESOME STAFF'
	EVEN
T204	DATA 4
	TEXT '3M07'
	EVEN
S201	DATA TF3TI11,0,0,0

GAMEOVERINFO
	DATA T211,T212,T213,T214,S211,4*8+10,0*8+3
T211	DATA 9
	TEXT 'GAME OVER'
	EVEN
T212	DATA 7
	TEXT 'NO MORE'
	EVEN
T213	DATA 4
	TEXT 'NONE'
	EVEN
T214	DATA 4
	TEXT '0M04'
	EVEN
S211	DATA TF3TI00,3,0,0

SQUADINFO
	DATA T221,T222,T223,T224,S221,4*8+10,0*8+3
T221	DATA 11
	TEXT 'METAL SQUAD'
	EVEN
T222	DATA 9
	TEXT 'TFIV WALL'
	EVEN
T223	DATA 9
	TEXT 'EVIL CORE'
	EVEN
T224	DATA 4
	TEXT '4M40'
	EVEN
S221	DATA TF3TI12,0,TF3TI13,0

TF4STAFFINFO
	DATA T231,T232,T233,T234,S231,4*8+10,0*8+3
T231	DATA 23
	TEXT 'STAND UP AGAINST MYSELF'
	EVEN
T232	DATA 10
	TEXT 'TFIV STAFF'
	EVEN
T233	DATA 18
	TEXT 'MORE AWESOME STAFF'
	EVEN
T234	DATA 4
	TEXT '1M49'
	EVEN
S231	DATA TF3TI12,0,TF3TI13,0

*****************
* Keyboard
* No input, return on R1 LSB (FF = no key)
* Warning: no debounce - that may be a problem on real hardware
KSCAN	CLR R0
KEYLP1	LI R12,>0024		* column select
		LDCR R0,3
		LI R12,>0006		* row select
		CLR R1				* so that the other byte will be zeroed
		STCR R1,8			* pressed keys are '0' bits
		CLR R2
		SWPB R1
KSHIFT	SRL R1,1
		JNC KFND
		INC R2
		JMP KSHIFT
KFND	CI R2,8				* check for overflow (no key)
		JL GOTKEY
		AI R0,>0100			* next column
		CI R0,>0600
		JNE KEYLP1
		LI R1,>00FF			* no key
		B *R11
GOTKEY	SWPB R0
		SLA R0,3
		A R2,R0
		ai r0,KEYMAP
		MOVB *R0,R1			* ASCII code
		SRL R1,8			* shift and clear MSB
		B *R11

* By columns, then rows. 8 Rows per column. No shift states
KEYMAP	BYTE 61,32,13,255,1,2,3,255
		TEXT '.LO92SWX'
		TEXT ',KI83DEC'
		TEXT 'MJU74FRV'
		TEXT 'NHY65GTB'
		TEXT '/;P01AQZ'
		EVEN

* Mute audio
MUTE
	li r0,>9FBF
	movb r0,@>8400
	swpb r0
	movb r0,@>8400
	li r0,>DFFF
	movb r0,@>8400
	swpb r0
	movb r0,@>8400
	b *r11

*****************
**	
* VDP access
*
* Raw versions assume address is preswapped and pre-masked,
* and do not attempt to preserve the value in R0
*

**
* VSBR - Read single byte at R0 into MSB R1
VSBR	
	SWPB R0
VSBRRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	MOVB @>8800,R1		* read byte
	B *R11

**
* VMBR - Read R2 bytes from VDP R0 to CPU R1
* Destroys R1,R2
VMBR
	SWPB R0
VMBRRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	COC @BIT01,R2		* check if odd
	JNE VMBRLP			* jump if not
	MOVB @>8800,*R1+	* read one byte
	DEC R2				* count down
	JEQ VMBREX			* jump ahead to exit if zero
VMBRLP
	MOVB @>8800,*R1+	* read two bytes
	MOVB @>8800,*R1+
	DECT R2				* count down by two
	JNE VMBRLP			* loop till finished
VMBREX
	B *R11				* return
	
**
* VSBW - Write single byte to R0 from MSB R1
* Destroys R0 (actually just oRs it)
VSBW
	ORI R0,>4000		* mask in write bit
	SWPB R0
VSBWRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* write address
	MOVB R1,*R8			* write data
	B *R11

**
* V2BW - Write two bytes to R0 from R1
* Destroys R0 (actually just oRs it)
V2BW
	ORI R0,>4000
	SWPB R0
V2BWRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9		* set address
	MOVB R1,*R8		* write data 1
	SWPB R1
	MOVB R1,*R8		* write data 2
	B *R11

**
* V2BR - Reads two bytes from R0 to R1
V2BR
	SWPB R0
V2BRRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	MOV R0,R0			* delay
	MOVB @>8800,R1		* read first byte
	SWPB R1
	MOVB @>8800,R1		* read second byte
	SWPB R1
	B *R11

**
* VMBW - Write R2 bytes from CPU R1 to VDP R0
* Destroys R0,R1,R2
* Copied to scratchpad - DO NOT MAKE LARGER
VMBW EQU >8340
VMBWSC
	ORI R0,>4000
	SWPB R0
VMBWRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	COC @BIT01,R2		* Check for odd length
	JNE VMBWLP			* jump to x2 loop if not odd
	MOVB *R1+,*R8		* copy one byte
	DEC R2				* count down
	JEQ VMBWEX			* jump to exit if done
VMBWLP
	MOVB *R1+,*R8		* write one byte
	MOVB *R1+,*R8		* write two bytes
	DECT R2				* count down
	JNE VMBWLP			* loop till finished
VMBWEX
	B *R11
vmbwend
	
**
* VMBS - Set R2 bytes from R1 MSB to VDP R0
* Destroys R0,R1,R2
VMBS
	ORI R0,>4000
	SWPB R0
VMBSRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	COC @BIT01,R2		* Check for odd length
	JNE VMBSLP			* jump to x2 loop if not odd
	MOVB R1,*R8			* copy once
	DEC R2				* count down
	JEQ VMBSEX			* jump to exit if done
VMBSLP
	MOVB R1,*R8			* write byte
	MOVB R1,*R8			* write second byte
	DECT R2				* count down
	JNE VMBSLP			* loop till finished
VMBSEX
	B *R11

**
* VDPWA - Write address or register
VDPWA
	SWPB R0
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9		* write address
	B *R11  
	
**
* LOADRG - load regs list to VDP address, end on >0000 and 
* write >D0 (for sprites) (so second to last entry is write address for sprite table)
* address of table in R1 (destroyed)
LOADRG
LOADLP
	MOV *R1+,R0
	JEQ LDRDN
	SWPB R0
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9
	JMP LOADLP
LDRDN
	LI R1,>D000
	MOVB R1,*R8
	B *R11

***

* wait r4 jiffies - this one ALSO calls the sound player
* this one, you can safely set r4 to 0
* uses r0,r12
* ** BIG WARNING ** - this changes ROM bank to R15 for the music!
delay
* reset the bank in case of QUIT
	mov r0,@>6000
	
* This quit test copied from the console ROM
	LI R12,>0024 		* Load CRU
	LDCR @>0012,3
	SRC R12,7			* delay
	LI R12,>0006
	STCR R0,8 			* Fetch CRU
	CZC @QUITK,R0 		* QUIT key?
	JNE MENUKY
	BLWP @>0000			* reboot if yes
MENUKY
	clr r12				* test CRU VDP interface
	tb 2
	jeq delay
	movb @>8802,r12
	
	mov r15,*r15		* bank switch (or nothing if cleared)
	jeq noSong
	
	lwpi >8300
	bl @SongLoop		* play music
	lwpi >8320
noSong 

	dec r4
	jgt delay
	b *r11

* r3 - bitmap VDP offset for color and pattern
* r4 - page to read data (data comes from page header)
loadpagevdp
	mov r11,r10			* save return
	mov r4,*r4			* bank switch
	mov r3,r0			* address to write pattern
	mov @>6004,r1		* pattern table in ROM
	mov @>6000,r2		* number of bytes of chars
	bl @vmbw
	ai r0,>2000			* address to write color
	mov @>6002,r1		* color table in ROM
	mov @>6000,r2		* number of bytes
	bl @vmbw
	b *r10				* chars loaded
	

* draw the ship at any X overlaid on the background into a CPU buffer
* R0 - target CPU address
* R1 - source CPU address for background row (must be paged already)
* R2 - number of rows to copy
* R3 - X offset of the ship (assumed to start at >7005 and be 22 chars wide)
* uses R4,R5,R6
* All kinds of assumptions about the data layout made here
* This is now copied to scratchpad and used at >8362
shipdraw equ >8362
shipdrawsc
* first, fast copy of background data, so we can get away with fewer compares
	mov r0,r4
	mov r1,r5
	mov r2,r6
	sla r6,2			* make it groups of 8 instead of 32
sdl1
	mov *r5+,*r4+
	mov *r5+,*r4+
	mov *r5+,*r4+
	mov *r5+,*r4+
	dec r6
	jne sdl1			* warning - this is patched in scratchpad, don't change offset!
	
* now, we have to do a byte by byte copy of the ship, checking for zero
* the ship data IS 32 bytes wide, but we only need to check 22, so we'll fake the
* loop that way. We just adjust bytes to rows
	a r3,r0			* target
	ai r1,(32*8)+5	* we should start exactly one section down, plus 5 for the start of ship data
	
sdl2
	li r5,22		* bytes across
sdl4
	movb *r1+,r4	* what is the byte?
	jeq sdl3		* skip ahead if nul
	czc @chk32,r3
	jne sdl3		* check for column clip
	movb r4,*r0		* else copy it
sdl3
	inc r0			* update target either way
	inc r3			* and column for clip checks
	dec r5
	jne sdl4		* finish the row
	
	ai r0,10
	ai r1,10		* wrap around to start of next row
	ai r3,-22		* fix r3
	dec r2			* count down rows
	jne sdl2
	
	b *r11			* all done
shipend


* draw the title characters on the screen with row index r5
* r5 - row from 0-9
* Since we never need to REDRAW anything, we can just draw the one row
drawtit
	data drawtit0,drawtit1,drawtit2,drawtit3,drawtit4
	data drawtit5,drawtit6,drawtit7,drawtit8,drawtit9
	
drawtit0
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+32+4
	mov @>6008,r1
	ai r1,(32*16)+32+4
	li r2,4
	bl @vmbw
	
	mov r0,@maptitlethird2
	
	li r0,>1800+(32*10)+8
	mov @>6008,r1
	ai r1,(32*16)+(2*32)+8
	li r2,1
	bl @vmbw
	
	li r0,>1800+(32*10)+11
	mov @>6008,r1
	ai r1,(32*16)+(2*32)+11
	li r2,1
	bl @vmbw

	li r0,>1800+(32*10)+16
	mov @>6008,r1
	ai r1,(32*16)+(2*32)+16
	li r2,4
	bl @vmbw

	b *r10
	
drawtit1
	mov r11,r10

	mov r0,@maptitlethird1
	
	li r0,>1800+(32*2)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+6
	li r2,2
	bl @vmbw
	
	li r0,>1800+(32*2)+13
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+13
	li r2,3
	bl @vmbw
	
	li r0,>1800+(32*2)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+20
	li r2,4
	bl @vmbw

	mov r0,@maptitlethird2
	
	li r0,>1800+(32*9)+8
	mov @>6008,r1
	ai r1,(32*16)+32+8
	li r2,1
	bl @vmbw
	
	li r0,>1800+(32*9)+11
	mov @>6008,r1
	ai r1,(32*16)+32+11
	li r2,1
	bl @vmbw

	li r0,>1800+(32*9)+16
	mov @>6008,r1
	ai r1,(32*16)+32+16
	li r2,4
	bl @vmbw

	li r0,>1800+(32*9)+24
	mov @>6008,r1
	ai r1,(32*16)+32+24
	li r2,1
	bl @vmbw

	b *r10
	
drawtit2
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*3)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+6
	li r2,2
	bl @vmbw

	li r0,>1800+(32*3)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+12
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*3)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+20
	li r2,4
	bl @vmbw

	mov r0,@maptitlethird2
	
	li r0,>1800+(32*8)+8
	mov @>6008,r1
	ai r1,(32*16)+8
	li r2,4
	bl @vmbw

	li r0,>1800+(32*8)+16
	mov @>6008,r1
	ai r1,(32*16)+16
	li r2,3
	bl @vmbw

	li r0,>1800+(32*8)+24
	mov @>6008,r1
	ai r1,(32*16)+24
	li r2,1
	bl @vmbw
	
	b *r10

drawtit3
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*4)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+6
	li r2,2
	bl @vmbw

	li r0,>1800+(32*4)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+12
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*4)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+20
	li r2,4
	bl @vmbw
	
		
	li r0,>1800+(32*7)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+8
	li r2,4
	bl @vmbw

	li r0,>1800+(32*7)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+16
	li r2,4
	bl @vmbw

	li r0,>1800+(32*7)+24
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+24
	li r2,1
	bl @vmbw
	
	b *r10
	
drawtit4
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*5)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+6
	li r2,2
	bl @vmbw

	li r0,>1800+(32*5)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+12
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*5)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+20
	li r2,4
	bl @vmbw
	
	
	li r0,>1800+(32*6)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*6)+8
	li r2,4
	bl @vmbw

	b *r10
	
drawtit5
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*6)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*6)+6
	li r2,2
	bl @vmbw

	li r0,>1800+(32*6)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*6)+12
	li r2,1
	bl @vmbw
	
	
	li r0,>1800+(32*5)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+8
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*5)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+16
	li r2,4
	bl @vmbw

	li r0,>1800+(32*5)+25
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+25
	li r2,1
	bl @vmbw

	li r0,>1800+(32*5)+27
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+27
	li r2,1
	bl @vmbw

	b *r10
	
drawtit6
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*7)+7
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+7
	li r2,1
	bl @vmbw

	li r0,>1800+(32*7)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+12
	li r2,4
	bl @vmbw

	li r0,>1800+(32*7)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+20
	li r2,4
	bl @vmbw
	
	
	li r0,>1800+(32*4)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+8
	li r2,4
	bl @vmbw

	li r0,>1800+(32*4)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+16
	li r2,4
	bl @vmbw

	li r0,>1800+(32*4)+24
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+24
	li r2,4
	bl @vmbw
	
	b *r10

drawtit7
	mov r11,r10
	
	mov r0,@maptitlethird2
	
	li r0,>1800+(32*8)+7
	mov @>6008,r1
	ai r1,(32*16)+(32*0)+7
	li r2,1
	bl @vmbw

	li r0,>1800+(32*8)+13
	mov @>6008,r1
	ai r1,(32*16)+(32*0)+13
	li r2,3
	bl @vmbw

	li r0,>1800+(32*8)+21
	mov @>6008,r1
	ai r1,(32*16)+(32*0)+21
	li r2,3
	bl @vmbw
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*3)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+8
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*3)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+16
	li r2,3
	bl @vmbw

	li r0,>1800+(32*3)+24
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+24
	li r2,4
	bl @vmbw

	b *r10
	
drawtit8
	mov r11,r10
	
	mov r0,@maptitlethird2
	
	li r0,>1800+(32*9)+7
	mov @>6008,r1
	ai r1,(32*16)+(32*1)+7
	li r2,1
	bl @vmbw

	li r0,>1800+(32*9)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*1)+12
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*9)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*1)+20
	li r2,4
	bl @vmbw
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*2)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+8
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*2)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+16
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*2)+24
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+24
	li r2,4
	bl @vmbw
	
	b *r10
	
drawtit9
	mov r11,r10
	
	mov r0,@maptitlethird2
	
	li r0,>1800+(32*10)+7
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+7
	li r2,1
	bl @vmbw

	li r0,>1800+(32*10)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+12
	li r2,4
	bl @vmbw

	li r0,>1800+(32*10)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+20
	li r2,4
	bl @vmbw

	mov r0,@maptitlethird1
	
	li r0,>1800+(32*1)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*1)+8
	li r2,2
	bl @vmbw
	
	b *r10
	
* translation to convert ascii to the silly places I put text...
* 0 is at 26, A (blue) is at 43, a (yellow) is at 77
* delta is -22 for numbers and uppercase, -20 for lowercase
* we take no responsibility for non-alphanumerics.
* R0 - VDP address
* R1 - CPU address
* R2 - bytes to copy
showtext
	ori r0,>4000		* set address for write
	swpb r0
	movb r0,*r9
	swpb r0
	movb r0,*r9
	
	clr r0
stlp
	movb *r1+,r0
	ci r0,>2000			* space
	jne stlp3
	clr r0
	jmp stlp2
stlp3
	ai r0,>EA00			* -22
	ci r0,>4b00			* lowercase A after subtraction
	jlt stlp2
	ai r0,>0200			* give the 2 back
stlp2
	movb r0,*r8
	dec r2
	jne stlp
	
	b *r11
	
* place crosshair sprites
* R6 - row (world map only)
* r7 - column (world map only)
* r13 - row offset
* r14 - column offset
drawcrosshairs
	li r0,>5b00
	SWPB R0
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9		* write address
	
	li r1,>7400		* vertical beam (4 of these)
	li r2,>0800		* dark red

	mov r13,r0		* first row
	a r14,r7
	swpb r0
	swpb r7
	movb r0,*r8		* row
	movb r7,*r8		* col
	movb r1,*r8		* char
	movb r2,*r8		* color
	ai r0,>2000
	movb r0,*r8		* row
	movb r7,*r8		* col
	movb r1,*r8		* char
	movb r2,*r8		* color
	ai r0,>2000
	movb r0,*r8		* row
	movb r7,*r8		* col
	movb r1,*r8		* char
	movb r2,*r8		* color
	ai r0,>2000
	movb r0,*r8		* row
	movb r7,*r8		* col
	movb r1,*r8		* char
	movb r2,*r8		* color
	swpb r7
	s r14,r7

	li r1,>7800		* horizontal beam (3 of these)
	mov r14,r0		* first column
	a r13,r6
	swpb r0
	swpb r6
	movb r6,*r8		* row
	movb r0,*r8		* col
	movb r1,*r8		* char
	movb r2,*r8		* color
	ai r0,>2000
	movb r6,*r8		* row
	movb r0,*r8		* col
	movb r1,*r8		* char
	movb r2,*r8		* color
	ai r0,>2000
	movb r6,*r8		* row
	movb r0,*r8		* col
	movb r1,*r8		* char
	movb r2,*r8		* color
	swpb r6
	s r13,r6
	
	b *r11

********************* MAIN CODE HERE **********************

START
* load workspace, R8 and R9, then we can start
	lwpi >8320
	li r8,>8c00
	li r9,>8c02

* turn VDP back off again (assumes that loader already set up bitmap)
* turn on with >81E3
	li r0,>81A3
	bl @VDPWA

* init the music player by calling StopSong
	clr r15					* r15 will hold the song bank
	bl @StopSong

* now copy vmbw into scratchpad ram for better blit speed
	li r0,vmbw
	li r1,vmbwsc
vcplp
	mov *r1+,*r0+
	ci r1,vmbwend
	jne vcplp
	
* clear the screen again
	li r0,>1800
	clr r1
	li r2,>300
	bl @VMBS
	
* first, we need to load up the title page. There are three banks involved
	clr r3					* pattern offset
	li r4,maptitlethird1	* page
	bl @loadpagevdp
	li r0,>1800				* SIT address
	mov @>6008,r1			* ROM address
	li r2,256				* 1/3rd of background screen
	bl @vmbw
	
	ai r3,>0800
	li r4,maptitlethird2	* page
	bl @loadpagevdp
	li r0,>1900				* SIT address
	mov @>6008,r1			* ROM address
	li r2,256				* 1/3rd of background screen
	bl @vmbw
	
	ai r3,>0800
	li r4,maptitlethird3	* page
	bl @loadpagevdp
	li r0,>1A00				* SIT address
	mov @>6008,r1			* ROM address
	li r2,256				* 1/3rd of background screen
	bl @vmbw
	
* finally, copy shipdraw to scratchpad to squeeze a little more speed out of it (helps)
	li r0,shipdrawsc
	li r1,shipdraw
sclp
	mov *r0+,*r1+
	ci r0,shipend
	jne sclp
	
* initialize the title music
	li r15,tf3ti00
	mov r15,*r15
	li r1,>6000
	clr r2
	bl @StartSong
	
* that's good, now we can turn on the screen and start the music
	li r0,>81E3
	bl @VDPWA
	
	
*********************************************
		b @startss
*********************************************
		
	
	
	
* first, a brief pause before the ship appears
	li r4,60
	bl @delay
	
* now we are going to flicker the ship in from left to right until it is centered
* the ship starts at row 12 and is 11 rows high
* rows 12-15 are in group 2, and 16-22 are in group 3 (different banks)
* it is 22 characters wide with 5 cells of gap on each side
* we also have to not draw 0-filled cells and clip at the edges
*
* We'll double buffer it to reduce the odds of unintended flicker, hopefully the
* work and blit will be quick enough - SCRNBUF is 11*32 bytes
*
shspeed equ 3

	li r13,-21					* x coordinate (for left side)
	li r14,shspeed				* frames to count
	
* draw the ship flickering at x=r13, then x=10-r13
shiplp
* first the left version, group 2 (last 4 rows)
	mov r0,@maptitlethird2		* bank it in
	li r0,SCRNBUF				* target address
	mov @>6008,r1				* map data for group 2 (first group is bg, last group is ship)
	ai r1,32*4					* skip to row 4 (which is really row 12, cause group 2)
	li r2,4						* copy 4 rows
	mov r13,r3					* ship offset
	bl @shipdraw				* call shipdraw
	li r0,>1900+(4*32)			* second third VDP
	li r1,SCRNBUF				* buffer we just made
	li r2,32*4					* 4 rows
	bl @vmbw					* get thee to VDP

* then group 3, 7 rows
	mov r0,@maptitlethird3		* bank it in
	li r0,SCRNBUF				* target address
	mov @>6008,r1				* map data for group 2 (first group is bg, last group is ship)
	li r2,7						* copy 7 rows
	mov r13,r3					* ship offset
	bl @shipdraw				* call shipdraw
	li r0,>1A00					* third third VDP
	li r1,SCRNBUF				* buffer we just made
	li r2,32*7					* 7 rows
	bl @vmbw					* get thee to VDP
	
	clr r4
	bl @delay					* frame delay
	ci r13,5					* silly to do this every time, but easy to get the last frame drawn ;)
	jeq shipdn
	
* now we need to do the same thing, but on the RIGHT side. We can skip the check for r13 though
* group 2 (last 4 rows)
	mov r0,@maptitlethird2		* bank it in
	li r0,SCRNBUF				* target address
	mov @>6008,r1				* map data for group 2 (first group is bg, last group is ship)
	ai r1,32*4					* skip to row 4 (which is really row 12, cause group 2)
	li r2,4						* copy 4 rows
	li r3,10					* ship far right
	s r13,r3					* ship offset
	bl @shipdraw				* call shipdraw
	li r0,>1900+(4*32)			* second third VDP
	li r1,SCRNBUF				* buffer we just made
	li r2,32*4					* 4 rows
	bl @vmbw					* get thee to VDP

* then group 3, 7 rows
	mov r0,@maptitlethird3		* bank it in
	li r0,SCRNBUF				* target address
	mov @>6008,r1				* map data for group 2 (first group is bg, last group is ship)
	li r2,7						* copy 7 rows
	li r3,10					* ship far right
	s r13,r3					* ship offset
	bl @shipdraw				* call shipdraw
	li r0,>1A00					* third third VDP
	li r1,SCRNBUF				* buffer we just made
	li r2,32*7					* 7 rows
	bl @vmbw					* get thee to VDP
	
	clr r4
	bl @delay					* frame delay

* count down and move if needed
	dec r14						* count down here
	jne shiplp
	
	li r14,shspeed				* reload it
	inc r13						* next step
	jmp shiplp					* and draw it either way (escape is right after the first delay)
shipdn

* there's about a half second delay here...
	li r4,40
	bl @delay

* now it's time for the title text. I'm thinking too hard about how to do it "right"
* so I'm going to do it completely manually ;) Takes more code, but we should have room to spare.

	clr r13						* frame counter
titlp
	mov @drawtit(r13),r1		* fetch function address
	bl *r1						* draw the relevant bits
	
	li r4,5
	bl @delay
	
	inct r13
	ci r13,20
	jne titlp

* all that's left now is the III blocking in. This lives from rows 11-14, columns 13-18
	li r13,TITIII				* random number table
	
tit3lp
	mov r0,@maptitlethird2		* bank in the second third

	mov *r13+,r1				* get random offset (+1)
	jeq tit3end					* if we're done, exit
	mov r1,r0					* save for VDP offset
	a @>6008,r1					* add md0 for ROM offset
	ai r1,(32*16)+(3*32)+12		* and get down to the title block, plus offset
	ai r0,>5800+(11*32)+12		* VDP write address
	bl @vdpwa					* set VDP address
	movb *r1,*r8				* write byte to VDP
	
	li r4,2
	bl @delay
	jmp tit3lp
tit3end

* now, we just wait for the music to end!
waitlp
	clr r4
	bl @delay
	
	movb @songNote+7,r0
	andi r0,>0100
	jne waitlp
	
* good, now we pause for a second...
	li r4,60
	bl @delay
	
* clear the screen, and wait for another half second
startss
	li r0,>1800
	clr r1
	li r2,768
	bl @vmbs
	
	li r4,30
	bl @delay
	
* next screen! Time for the stage select!
* load the character set (all three pages this one, at least to start)
	clr r3
	li r4,mapbriefing
	bl @loadpagevdp
	li r3,>800
	li r4,mapbriefing
	bl @loadpagevdp
	li r3,>1000
	li r4,mapbriefing
	bl @loadpagevdp
	
* and load the sprite graphics - no nicely defined pointer this time
	li r0,>1b80			* first free pattern
	mov @>6008,r1		* md0
	ai r1,-(16*8+10)		* distance back to start of sprite data
	li r2,16*8
	bl @vmbw
	
* and block out the sprite table
	li r0,>1b00
	li r1,>d000
	li r2,128
	bl @vmbs

* but, we aren't loading the briefing PAGE, just the world map
* which means we need to do it manually. The world map is at
* row 5, column 1, and is 14 cells wide and 17 cells tall

* display STAGE SELECT text in top row 
* but... nooooo, I couldn't put the alphabet at the ASCII location...
	li r0,>1800+10
	li r1,STAGESEL
	li r2,12
	bl @showtext
	
* no paging issues on this one, just bring it in, one row at a time
	li r4,>1800+(32*3)+9		* dest adr
	mov @>6008,r5				* address of MD0 (page still valid from above)
	ai r5,(5*32)+1				* location in the source map
	li r6,17					* number of rows
cpmapl1
	mov r4,r0
	mov r5,r1
	li r2,14
	bl @vmbw
	
	ai r4,32
	ai r5,32
	dec r6
	jne cpmapl1
	
* okay, static text is up, initialize our world and the music
	clr r5						* world (make sure to step by 2!)
	li r13,(3*8)-1+4			* row offset for sprite (to make the edges line up, NOT the center!)
	li r14,(9*8)+8				* col offset for sprite (to make the edges line up, NOT the center!)
	
	li r15,tf3ti01
	mov r0,*r15					* page it in
	li r1,>6000
	clr r2						* song 0 is select
	bl @StartSong
	
* now wait for the music to end. as a bonus, the human can select
* a stage with the arrow keys and space, which will change where we start
* the briefing screen

selectlp
* first, draw the crosshairs and world text
* we don't have to do much, so we can do this every frame
	clr r4
	bl @delay					* music and frame
	movb @songNote+7,r0			* check if music is stopped
	andi r0,>0100
	jeq selectover
	
selectnotover
	mov r5,r4					* make a copy
	mov @STAGETXT(r4),r4		* get the pointer
	
	mov *r4+,r6					* this is the row
	mov *r4+,r7					* column
	bl @drawcrosshairs
	
	li r0,>1800+(23*32)+13		* for writing the world name
	mov r4,r1
	li r2,6
	bl @showtext
	
	bl @kscan					* look for new keypress
	c r1,@oldkey
	jeq selectlp
	
	mov r1,@oldkey				* save it

* we're looking for S, D and Enter
	ci r1,>0053					* S
	jne NOTS
	
	inct r5
	ci r5,10
	jne nots2
	clr r5
nots2
	jmp selectlp
	
NOTS
	ci r1,>0044					* D
	jne NOTD
	
	dect r5
	ci r5,>fffe
	jne notd2
	li r5,8
notd2
	jmp selectlp
	
NOTD
	ci r1,>000D
	jne selectlp
	bl @StopSong
	bl @mute
	jmp selectlp
	
selectover

* Finally, we get to the meat of the player - the mission briefing screen
* there's a fair bit going on here

	clr r4
	bl @delay		* align with end of frame

* clear the sprites (temporarily)
	li r0,>1b00
	li r1,>d000
	li r2,128
	bl @vmbs
	
* and clear the screen...
	li r0,>1800
	clr r1
	li r2,768
	bl @vmbs
	
* graphics and sprites are already loaded, so we just need to bring up the mission screen
* as nice as it'd be to stay in registers, for simplicity we're going to track all this stuff as data
	mov r0,@mapbriefing		* page it in (probably already is)
	
	li r0,>1800
	mov @>6008,r1			* for once, we want the whole thing!
	li r2,768
	bl @vmbw
	
	li r13,(5*8)-1+4		* update the offsets for this map (row)
	li r14,(1*8)+8			* col
	li r6,>0400
	li r7,>0800				* current row and col for crosshairs - they move now (0,0 isn't legal)
	mov r6,@crosshairrow
	mov r7,@crosshaircol

	clr @weapon				* zero or 1 only
	
	clr @textline
	clr @textptr
	clr @textcount
	clr @textdelay			* data for displaying text in box
	
	clr @statusline			* index for the status line (changed by AID)
	
	ai r5,6					* finally, add 6 to the selected music, to skip null, title and stage select
	
	
	


	
	
	



	
	
	
	
	

	

* temp code - change screen	color so I know it's done
	li r0,>8733
	bl @vdpwa
lp
	clr r4
	bl @delay
	jmp lp
	
	END
	