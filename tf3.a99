* Thunder Force III Tribute music player
* 
* I first saw Thunder Force III back in 1987 or 1988, and have been hooked on it since.
* It's the reason I got a Sega Genesis, and I've always wanted my TI to do anything
* even remotely close. A major part of my vgmcomp2 music converter was wanting to
* be able to convert Genesis music, specifically for this sound track. So now, though
* I don't intend to do the whole game, I've used my conversion toolchains to do
* this little musical and graphical tribute.
* 
* There's a little over 64k of compressed music, and more than that in graphics, so
* there's a lot of bank switching. Each song fits in a single bank guaranteed, so
* that helps a lot. 
*
* I'm torn on making it run without needing the 32k memory expansion or not, since the
* actual RAM usage would work in the scratchpad, but I worry about the CPU usage of the
* player when every byte accessed actually takes a write and a read. All the paging would
* be painful and I've already spent too long on this.
*
* Soooo... this program is going to be executing from 32K RAM and a separate loader cart
* will exist.

* bank definitions
loader equ >6000
ea5pt1 equ >6002
ea5pt2 equ >6004
ea5pt3 equ >6006
tf3ti00 equ >6008
tf3ti01 equ >600a
tf3ti02 equ >600c
tf3ti03 equ >600e
tf3ti04 equ >6010
tf3ti05 equ >6012
tf3ti06 equ >6014
tf3ti07 equ >6016
tf3ti08 equ >6018
tf3ti09 equ >601a
tf3ti10 equ >601c
tf3ti11 equ >601e
tf3ti12 equ >6038
tf3ti13 equ >603a
tf3ti14 equ >603c
mapbossunknown equ >6020
mapbosscerberus equ >6022
mapbossfish equ >6024
mapbossfort equ >6026
mapbossgargoyle equ >6028
mapbosslobster equ >602a
mapbossvulcan equ >602c
mapbriefing equ >602e
mapbriefingornbase equ >6030
maptitlethird1 equ >6032
maptitlethird2 equ >6034
maptitlethird3 equ >6036

** WARNING: Do not use R8 and R9 - they containthe VDP write addresses, and R15 has the song bank

* memory allocation only, don't put initialized data here! It won't get loaded anyway!
* low ram for data buffers
	AORG >2000
	
* Music player	
strDat
	bss 72
songVol
	bss 4
songNote
	bss 8
workBuf
	bss 2
retSave
    bss 2
    
* tf3 stuff
SCRNBUF	BSS 11*32


* high RAM for program
	AORG >A000
	DEF START
	
	B @START

	COPY "tiSNonly.asm"

*****************
**	
* VDP access
*
* Raw versions assume address is preswapped and pre-masked,
* and do not attempt to preserve the value in R0
*

BIT01  DATA >0001
QUITK  DATA >1100				* CRU value for QUIT
CHK32  DATA >FFE0				* inverse of >1f for clip checks

**
* VSBR - Read single byte at R0 into MSB R1
VSBR	
	SWPB R0
VSBRRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	MOVB @>8800,R1		* read byte
	B *R11

**
* VMBR - Read R2 bytes from VDP R0 to CPU R1
* Destroys R1,R2
VMBR
	SWPB R0
VMBRRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	COC @BIT01,R2		* check if odd
	JNE VMBRLP			* jump if not
	MOVB @>8800,*R1+	* read one byte
	DEC R2				* count down
	JEQ VMBREX			* jump ahead to exit if zero
VMBRLP
	MOVB @>8800,*R1+	* read two bytes
	MOVB @>8800,*R1+
	DECT R2				* count down by two
	JNE VMBRLP			* loop till finished
VMBREX
	B *R11				* return
	
**
* VSBW - Write single byte to R0 from MSB R1
* Destroys R0 (actually just oRs it)
VSBW
	ORI R0,>4000		* mask in write bit
	SWPB R0
VSBWRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* write address
	MOVB R1,*R8			* write data
	B *R11

**
* V2BW - Write two bytes to R0 from R1
* Destroys R0 (actually just oRs it)
V2BW
	ORI R0,>4000
	SWPB R0
V2BWRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9		* set address
	MOVB R1,*R8		* write data 1
	SWPB R1
	MOVB R1,*R8		* write data 2
	B *R11

**
* V2BR - Reads two bytes from R0 to R1
V2BR
	SWPB R0
V2BRRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	MOV R0,R0			* delay
	MOVB @>8800,R1		* read first byte
	SWPB R1
	MOVB @>8800,R1		* read second byte
	SWPB R1
	B *R11

**
* VMBW - Write R2 bytes from CPU R1 to VDP R0
* Destroys R0,R1,R2
* Copied to scratchpad - DO NOT MAKE LARGER
VMBW EQU >8340
VMBWSC
	ORI R0,>4000
	SWPB R0
VMBWRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	COC @BIT01,R2		* Check for odd length
	JNE VMBWLP			* jump to x2 loop if not odd
	MOVB *R1+,*R8		* copy one byte
	DEC R2				* count down
	JEQ VMBWEX			* jump to exit if done
VMBWLP
	MOVB *R1+,*R8		* write one byte
	MOVB *R1+,*R8		* write two bytes
	DECT R2				* count down
	JNE VMBWLP			* loop till finished
VMBWEX
	B *R11
vmbwend
	
**
* VMBS - Set R2 bytes from R1 MSB to VDP R0
* Destroys R0,R1,R2
VMBS
	ORI R0,>4000
	SWPB R0
VMBSRAW
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9			* set address
	COC @BIT01,R2		* Check for odd length
	JNE VMBSLP			* jump to x2 loop if not odd
	MOVB R1,*R8			* copy once
	DEC R2				* count down
	JEQ VMBSEX			* jump to exit if done
VMBSLP
	MOVB R1,*R8			* write byte
	MOVB R1,*R8			* write second byte
	DECT R2				* count down
	JNE VMBSLP			* loop till finished
VMBSEX
	B *R11

**
* VDPWA - Write address or register
VDPWA
	SWPB R0
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9		* write address
	B *R11  
	
**
* LOADRG - load regs list to VDP address, end on >0000 and 
* write >D0 (for sprites) (so second to last entry is write address for sprite table)
* address of table in R1 (destroyed)
LOADRG
LOADLP
	MOV *R1+,R0
	JEQ LDRDN
	SWPB R0
	MOVB R0,*R9
	SWPB R0
	MOVB R0,*R9
	JMP LOADLP
LDRDN
	LI R1,>D000
	MOVB R1,*R8
	B *R11

***

* wait r4 jiffies - this one ALSO calls the sound player
* this one, you can safely set r4 to 0
* uses r5,r12
* ** BIG WARNING ** - this changes ROM bank to R15 for the music!
delay
* reset the bank in case of QUIT
	mov r0,@>6000
	
* This quit test copied from the console ROM
	LI R12,>0024 		* Load CRU
	LDCR @>0012,3
	SRC R12,7			* delay
	LI R12,>0006
	STCR R5,8 			* Fetch CRU
	CZC @QUITK,R5 		* QUIT key?
	JNE MENUKY
	BLWP @>0000			* reboot if yes
MENUKY
	clr r12				* test CRU VDP interface
	tb 2
	jeq delay
	movb @>8802,r12
	
	mov r15,*r15		* bank switch (or nothing if cleared)
	jeq noSong
	
	lwpi >8300
	bl @SongLoop		* play music
	lwpi >8320
noSong 

	dec r4
	jgt delay
	b *r11

* r3 - bitmap VDP offset for color and pattern
* r4 - page to read data (data comes from page header)
loadpagevdp
	mov r11,r10			* save return
	mov r4,*r4			* bank switch
	mov r3,r0			* address to write pattern
	mov @>6004,r1		* pattern table in ROM
	mov @>6000,r2		* number of bytes of chars
	bl @vmbw
	ai r0,>2000			* address to write color
	mov @>6002,r1		* color table in ROM
	mov @>6000,r2		* number of bytes
	bl @vmbw
	b *r10				* chars loaded
	

* draw the ship at any X overlaid on the background into a CPU buffer
* R0 - target CPU address
* R1 - source CPU address for background row (must be paged already)
* R2 - number of rows to copy
* R3 - X offset of the ship (assumed to start at >7005 and be 22 chars wide)
* uses R4,R5,R6
* All kinds of assumptions about the data layout made here
* This is now copied to scratchpad and used at >8362
shipdraw equ >8362
shipdrawsc
* first, fast copy of background data, so we can get away with fewer compares
	mov r0,r4
	mov r1,r5
	mov r2,r6
	sla r6,2			* make it groups of 8 instead of 32
sdl1
	mov *r5+,*r4+
	mov *r5+,*r4+
	mov *r5+,*r4+
	mov *r5+,*r4+
	dec r6
	jne sdl1			* warning - this is patched in scratchpad, don't change offset!
	
* now, we have to do a byte by byte copy of the ship, checking for zero
* the ship data IS 32 bytes wide, but we only need to check 22, so we'll fake the
* loop that way. We just adjust bytes to rows
	a r3,r0			* target
	ai r1,(32*8)+5	* we should start exactly one section down, plus 5 for the start of ship data
	
sdl2
	li r5,22		* bytes across
sdl4
	movb *r1+,r4	* what is the byte?
	jeq sdl3		* skip ahead if nul
	czc @chk32,r3
	jne sdl3		* check for column clip
	movb r4,*r0		* else copy it
sdl3
	inc r0			* update target either way
	inc r3			* and column for clip checks
	dec r5
	jne sdl4		* finish the row
	
	ai r0,10
	ai r1,10		* wrap around to start of next row
	ai r3,-22		* fix r3
	dec r2			* count down rows
	jne sdl2
	
	b *r11			* all done
shipend


* draw the title characters on the screen with row index r5
* r5 - row from 0-9
* Since we never need to REDRAW anything, we can just draw the one row
* TODO: if we need to reclaim space, we could use a loop with a table...
drawtit
	data drawtit0,drawtit1,drawtit2,drawtit3,drawtit4
	data drawtit5,drawtit6,drawtit7,drawtit8,drawtit9
	
drawtit0
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+32+4
	mov @>6008,r1
	ai r1,(32*16)+32+4
	li r2,4
	bl @vmbw
	
	mov r0,@maptitlethird2
	
	li r0,>1800+(32*10)+8
	mov @>6008,r1
	ai r1,(32*16)+(2*32)+8
	li r2,1
	bl @vmbw
	
	li r0,>1800+(32*10)+11
	mov @>6008,r1
	ai r1,(32*16)+(2*32)+11
	li r2,1
	bl @vmbw

	li r0,>1800+(32*10)+16
	mov @>6008,r1
	ai r1,(32*16)+(2*32)+16
	li r2,4
	bl @vmbw

	b *r10
	
drawtit1
	mov r11,r10

	mov r0,@maptitlethird1
	
	li r0,>1800+(32*2)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+6
	li r2,2
	bl @vmbw
	
	li r0,>1800+(32*2)+13
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+13
	li r2,3
	bl @vmbw
	
	li r0,>1800+(32*2)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+20
	li r2,4
	bl @vmbw

	mov r0,@maptitlethird2
	
	li r0,>1800+(32*9)+8
	mov @>6008,r1
	ai r1,(32*16)+32+8
	li r2,1
	bl @vmbw
	
	li r0,>1800+(32*9)+11
	mov @>6008,r1
	ai r1,(32*16)+32+11
	li r2,1
	bl @vmbw

	li r0,>1800+(32*9)+16
	mov @>6008,r1
	ai r1,(32*16)+32+16
	li r2,4
	bl @vmbw

	li r0,>1800+(32*9)+24
	mov @>6008,r1
	ai r1,(32*16)+32+24
	li r2,1
	bl @vmbw

	b *r10
	
drawtit2
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*3)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+6
	li r2,2
	bl @vmbw

	li r0,>1800+(32*3)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+12
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*3)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+20
	li r2,4
	bl @vmbw

	mov r0,@maptitlethird2
	
	li r0,>1800+(32*8)+8
	mov @>6008,r1
	ai r1,(32*16)+8
	li r2,4
	bl @vmbw

	li r0,>1800+(32*8)+16
	mov @>6008,r1
	ai r1,(32*16)+16
	li r2,3
	bl @vmbw

	li r0,>1800+(32*8)+24
	mov @>6008,r1
	ai r1,(32*16)+24
	li r2,1
	bl @vmbw
	
	b *r10

drawtit3
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*4)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+6
	li r2,2
	bl @vmbw

	li r0,>1800+(32*4)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+12
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*4)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+20
	li r2,4
	bl @vmbw
	
		
	li r0,>1800+(32*7)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+8
	li r2,4
	bl @vmbw

	li r0,>1800+(32*7)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+16
	li r2,4
	bl @vmbw

	li r0,>1800+(32*7)+24
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+24
	li r2,1
	bl @vmbw
	
	b *r10
	
drawtit4
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*5)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+6
	li r2,2
	bl @vmbw

	li r0,>1800+(32*5)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+12
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*5)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+20
	li r2,4
	bl @vmbw
	
	
	li r0,>1800+(32*6)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*6)+8
	li r2,4
	bl @vmbw

	b *r10
	
drawtit5
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*6)+6
	mov @>6008,r1
	ai r1,(32*16)+(32*6)+6
	li r2,2
	bl @vmbw

	li r0,>1800+(32*6)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*6)+12
	li r2,1
	bl @vmbw
	
	
	li r0,>1800+(32*5)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+8
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*5)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+16
	li r2,4
	bl @vmbw

	li r0,>1800+(32*5)+25
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+25
	li r2,1
	bl @vmbw

	li r0,>1800+(32*5)+27
	mov @>6008,r1
	ai r1,(32*16)+(32*5)+27
	li r2,1
	bl @vmbw

	b *r10
	
drawtit6
	mov r11,r10
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*7)+7
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+7
	li r2,1
	bl @vmbw

	li r0,>1800+(32*7)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+12
	li r2,4
	bl @vmbw

	li r0,>1800+(32*7)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*7)+20
	li r2,4
	bl @vmbw
	
	
	li r0,>1800+(32*4)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+8
	li r2,4
	bl @vmbw

	li r0,>1800+(32*4)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+16
	li r2,4
	bl @vmbw

	li r0,>1800+(32*4)+24
	mov @>6008,r1
	ai r1,(32*16)+(32*4)+24
	li r2,4
	bl @vmbw
	
	b *r10

drawtit7
	mov r11,r10
	
	mov r0,@maptitlethird2
	
	li r0,>1800+(32*8)+7
	mov @>6008,r1
	ai r1,(32*16)+(32*0)+7
	li r2,1
	bl @vmbw

	li r0,>1800+(32*8)+13
	mov @>6008,r1
	ai r1,(32*16)+(32*0)+13
	li r2,3
	bl @vmbw

	li r0,>1800+(32*8)+21
	mov @>6008,r1
	ai r1,(32*16)+(32*0)+21
	li r2,3
	bl @vmbw
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*3)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+8
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*3)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+16
	li r2,3
	bl @vmbw

	li r0,>1800+(32*3)+24
	mov @>6008,r1
	ai r1,(32*16)+(32*3)+24
	li r2,4
	bl @vmbw

	b *r10
	
drawtit8
	mov r11,r10
	
	mov r0,@maptitlethird2
	
	li r0,>1800+(32*9)+7
	mov @>6008,r1
	ai r1,(32*16)+(32*1)+7
	li r2,1
	bl @vmbw

	li r0,>1800+(32*9)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*1)+12
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*9)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*1)+20
	li r2,4
	bl @vmbw
	
	mov r0,@maptitlethird1
	
	li r0,>1800+(32*2)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+8
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*2)+16
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+16
	li r2,4
	bl @vmbw
	
	li r0,>1800+(32*2)+24
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+24
	li r2,4
	bl @vmbw
	
	b *r10
	
drawtit9
	mov r11,r10
	
	mov r0,@maptitlethird2
	
	li r0,>1800+(32*10)+7
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+7
	li r2,1
	bl @vmbw

	li r0,>1800+(32*10)+12
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+12
	li r2,4
	bl @vmbw

	li r0,>1800+(32*10)+20
	mov @>6008,r1
	ai r1,(32*16)+(32*2)+20
	li r2,4
	bl @vmbw

	mov r0,@maptitlethird1
	
	li r0,>1800+(32*1)+8
	mov @>6008,r1
	ai r1,(32*16)+(32*1)+8
	li r2,2
	bl @vmbw
	
	b *r10

* random data for displaying III
* generated in BLASSIC, 26 entries of y*32+x+1
TITIII
	DATA 70,66,99,101,2,34,98,5,102,3,37,35,65,97,36,69,38,68,4,1,100,6,33,67
	DATA 0
	
********************* MAIN CODE HERE **********************

START
* load workspace, R8 and R9, then we can start
	lwpi >8320
	li r8,>8c00
	li r9,>8c02

* turn VDP back off again (assumes that loader already set up bitmap)
* turn on with >81E2
	li r0,>81A2
	bl @VDPWA

* init the music player by calling StopSong
	clr r15					* r15 will hold the song bank
	bl @StopSong

* now copy vmbw into scratchpad ram for better blit speed
	li r0,vmbw
	li r1,vmbwsc
vcplp
	mov *r1+,*r0+
	ci r1,vmbwend
	jne vcplp
	
* clear the screen again
	li r0,>1800
	clr r1
	li r2,>300
	bl @VMBS
	
* first, we need to load up the title page. There are three banks involved
	clr r3					* pattern offset
	li r4,maptitlethird1	* page
	bl @loadpagevdp
	li r0,>1800				* SIT address
	mov @>6008,r1			* ROM address
	li r2,256				* 1/3rd of background screen
	bl @vmbw
	
	ai r3,>0800
	li r4,maptitlethird2	* page
	bl @loadpagevdp
	li r0,>1900				* SIT address
	mov @>6008,r1			* ROM address
	li r2,256				* 1/3rd of background screen
	bl @vmbw
	
	ai r3,>0800
	li r4,maptitlethird3	* page
	bl @loadpagevdp
	li r0,>1A00				* SIT address
	mov @>6008,r1			* ROM address
	li r2,256				* 1/3rd of background screen
	bl @vmbw
	
* finally, copy shipdraw to scratchpad to squeeze a little more speed out of it (helps)
	li r0,shipdrawsc
	li r1,shipdraw
sclp
	mov *r0+,*r1+
	ci r0,shipend
	jne sclp
	
* initialize the title music
	li r15,tf3ti00
	mov r15,*r15
	li r1,>6000
	clr r2
	bl @StartSong
	
* that's good, now we can turn on the screen and start the music
	li r0,>81E2
	bl @VDPWA
	
* first, a brief pause before the ship appears
	li r4,60
	bl @delay
	
* now we are going to flicker the ship in from left to right until it is centered
* the ship starts at row 12 and is 11 rows high
* rows 12-15 are in group 2, and 16-22 are in group 3 (different banks)
* it is 22 characters wide with 5 cells of gap on each side
* we also have to not draw 0-filled cells and clip at the edges
*
* We'll double buffer it to reduce the odds of unintended flicker, hopefully the
* work and blit will be quick enough - SCRNBUF is 11*32 bytes
*
shspeed equ 2

	li r13,-21					* x coordinate (for left side)
	li r14,shspeed				* frames to count
	
* draw the ship flickering at x=r13, then x=10-r13
shiplp
* first the left version, group 2 (last 4 rows)
	mov r0,@maptitlethird2		* bank it in
	li r0,SCRNBUF				* target address
	mov @>6008,r1				* map data for group 2 (first group is bg, last group is ship)
	ai r1,32*4					* skip to row 4 (which is really row 12, cause group 2)
	li r2,4						* copy 4 rows
	mov r13,r3					* ship offset
	bl @shipdraw				* call shipdraw
	li r0,>1900+(4*32)			* second third VDP
	li r1,SCRNBUF				* buffer we just made
	li r2,32*4					* 4 rows
	bl @vmbw					* get thee to VDP

* then group 3, 7 rows
	mov r0,@maptitlethird3		* bank it in
	li r0,SCRNBUF				* target address
	mov @>6008,r1				* map data for group 2 (first group is bg, last group is ship)
	li r2,7						* copy 7 rows
	mov r13,r3					* ship offset
	bl @shipdraw				* call shipdraw
	li r0,>1A00					* third third VDP
	li r1,SCRNBUF				* buffer we just made
	li r2,32*7					* 7 rows
	bl @vmbw					* get thee to VDP
	
	clr r4
	bl @delay					* frame delay
	ci r13,5					* silly to do this every time, but easy to get the last frame drawn ;)
	jeq shipdn
	
* now we need to do the same thing, but on the RIGHT side. We can skip the check for r13 though
* group 2 (last 4 rows)
	mov r0,@maptitlethird2		* bank it in
	li r0,SCRNBUF				* target address
	mov @>6008,r1				* map data for group 2 (first group is bg, last group is ship)
	ai r1,32*4					* skip to row 4 (which is really row 12, cause group 2)
	li r2,4						* copy 4 rows
	li r3,10					* ship far right
	s r13,r3					* ship offset
	bl @shipdraw				* call shipdraw
	li r0,>1900+(4*32)			* second third VDP
	li r1,SCRNBUF				* buffer we just made
	li r2,32*4					* 4 rows
	bl @vmbw					* get thee to VDP

* then group 3, 7 rows
	mov r0,@maptitlethird3		* bank it in
	li r0,SCRNBUF				* target address
	mov @>6008,r1				* map data for group 2 (first group is bg, last group is ship)
	li r2,7						* copy 7 rows
	li r3,10					* ship far right
	s r13,r3					* ship offset
	bl @shipdraw				* call shipdraw
	li r0,>1A00					* third third VDP
	li r1,SCRNBUF				* buffer we just made
	li r2,32*7					* 7 rows
	bl @vmbw					* get thee to VDP
	
	clr r4
	bl @delay					* frame delay

* count down and move if needed
	dec r14						* count down here
	jne shiplp
	
	li r14,shspeed				* reload it
	inc r13						* next step
	jmp shiplp					* and draw it either way (escape is right after the first delay)
shipdn

* now it's time for the title text. I'm thinking too hard about how to do it "right"
* so I'm going to do it completely manually ;) Takes more code, but we should have room to spare.

	clr r13						* frame counter
titlp
	mov @drawtit(r13),r1		* fetch function address
	bl *r1						* draw the relevant bits
	
	li r4,5
	bl @delay
	
	inct r13
	ci r13,20
	jne titlp

* all that's left now is the III blocking in. This lives from rows 11-14, columns 13-18
	li r13,TITIII				* random number table
	
tit3lp
	mov r0,@maptitlethird2		* bank in the second third

	mov *r13+,r1				* get random offset (+1)
	jeq tit3end					* if we're done, exit
	mov r1,r0					* save for VDP offset
	a @>6008,r1					* add md0 for ROM offset
	ai r1,(32*16)+(3*32)+12		* and get down to the title block, plus offset
	ai r0,>5800+(11*32)+12		* VDP write address
	bl @vdpwa					* set VDP address
	movb *r1,*r8				* write byte to VDP
	
	li r4,2
	bl @delay
	jmp tit3lp
tit3end

	

	
lp
	clr r4
	bl @delay
	jmp lp
	
	END
	